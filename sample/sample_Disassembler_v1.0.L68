00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.13.00
Created On: 11/17/2013 1:11:11 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Team SaB Disassembler
00000000                             3  * Written by : Kyle Rindahl & Mitch Carlson
00000000                             4  * Date       : Feb. 22, 2013
00000000                             5  * Description: Disassembler v1.0
00000000                             6  *-----------------------------------------------------------
00000000                             7  *******************************************************************************
00000000                             8  */////////////////////////////////////////////////////////////////////////////*
00000000                             9  *                           Universal Project Notes                           *
00000000                            10  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
00000000                            11  *******************************************************************************
00000000                            12  *
00000000                            13  * A4: Address pointer for disassemble
00000000                            14  * A6: used by op-code and EA routine for buffer pointer
00000000                            15  * A7: Stack pointer for saving and maintaining registers
00000000                            16  * D6: Good/bad flag
00000000                            17  *
00000000                            18  *******************************************************************************
00000000                            19  */////////////////////////////////////////////////////////////////////////////*
00000000                            20  *                                 MAIN PROGRAM                                *
00000000                            21  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
00000000                            22  *******************************************************************************
00000000                            23  
00000000                            24              OPT     CRE                ;Bring in the Symbol Table
00001000                            25              ORG     $1000
00001000                            26  START                                   ;first instruction of program
00001000  4FF9 00100000             27              LEA     stack,SP           ;Stack pointer in A7
00001006  6100 000C                 28              BSR     GREETING
0000100A  6100 0130                 29              BSR     CONTROL            ;start process to ocr
0000100E  6100 0158                 30              BSR     ADDR_LOOP
00001012  60EC                      31              BRA     START
00001014                            32  
00001014                            33  *******************************************************************************
00001014                            34  */////////////////////////////////////////////////////////////////////////////*
00001014                            35  *                                  I/O Routine                                *
00001014                            36  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
00001014                            37  *******************************************************************************
00001014                            38  
00001014  =00002000                 39  strtAddr    EQU     $00002000           ;Starting Address for user input program
00001014  =000FFFFF                 40  endAddr     EQU     $000FFFFF           ;Ending Address - upper bound of input program
00001014  =000FFFFE                 41  badStart    EQU     $000FFFFE           ;Invalid starting Address if GTE 000FFFFE
00001014  =00000024                 42  dollar      EQU     $24                 ;ASCII $
00001014  =0000000A                 43  LF          EQU     $0A                 ;ASCII value for Line feed
00001014  =0000000D                 44  CR          EQU     $0D                 ;ASCII value for Carriage return
00001014  =00000020                 45  space       EQU     $20                 ;ASCII value for space
00001014  =0000002C                 46  comma       EQU     $2C                 ;ASCII value for comma
00001014  =00000000                 47  task0       EQU     00                  ;Task0 from Berger, print string w/ newline
00001014  =00000001                 48  task1       EQU     01                  ;Task1 from Berger, prompt for input w/o newline
00001014  =00000002                 49  task2       EQU     02                  ;Task2 from Berger, prompt and wait for input
00001014  =00001000                 50  start       EQU     $1000               ;Starting address of program
00001014  =00000008                 51  addrLen     EQU     08                  ;Address Length = 8 bytes
00001014  =00000004                 52  wordLen     EQU     04                  ;Word Length = 4 bytes
00001014  =00100000                 53  stack       EQU     $00100000           ;Default Location of Stack
00001014  =00000001                 54  evenAnd     EQU     $00000001           ;EvenCk subroutine check if a number is even
00001014  =00000044                 55  D           EQU     $44                 ;ASCII value for D
00001014  =00000041                 56  A           EQU     $41                 ;ASCII value for A
00001014  =00000054                 57  T           EQU     $54                 ;ASCII value for T
00001014  =0000004E                 58  upN         EQU     $4E                 ;ASCII value for N for User Prompt
00001014  =0000006E                 59  lwn         EQU     $6E                 ;ASCII value for n for User Prompt
00001014  =00000059                 60  upY         EQU     $59                 ;ASCII value for Y for User Prompt
00001014  =00000079                 61  lwY         EQU     $79                 ;ASCII value for y for User Prompt
00001014  =00000019                 62  outCt       EQU     25                  ;Will show 25 lines on each screen, can adjust
00001014  =00000050                 63  region      EQU     80                  ;decimal number 80 to help fill
00001014                            64  
00001014                            65  
00001014                            66  
00001014                            67  
00001014                            68  *Displays greeting to user, prompts to begin
00001014  103C 0000                 69  Greeting    MOVE.B      #task0,D0       ;Start of Greeting. Loads D0 with text from greeting
00001018  43F9 00001490             70              LEA         greet,A1        ;Load Greeting address into A1
0000101E  3239 000014EE             71              MOVE.W      greetL,D1       ;Store Greeting length into D1
00001024  4E4F                      72              TRAP        #15             ;Run
00001026                            73  
00001026  103C 0002                 74              MOVE.B      #task2,D0       ;D0 Input from user
0000102A  43F9 000013A8             75              LEA         decision,A1     ;Store input ptr to A1
00001030  4E4F                      76              TRAP        #15             ;Run
00001032                            77  
00001032  1411                      78              MOVE.B      (A1),D2         ;D2 holds first byte of input
00001034  0C02 0059                 79              CMPI.B      #upY,D2         ;Check if D2 == Y
00001038  6700 001E                 80              BEQ         procStart       ;Start disassembling
0000103C  0C02 0079                 81              CMPI.B      #lwY,D2         ;Check if D2 == y
00001040  6700 0016                 82              BEQ         procStart       ;Start disassembling
00001044  0C02 004E                 83              CMPI.B      #upN,D2         ;Check if D2(decision) == N
00001048  6700 0332                 84              BEQ         stp             ;Stop disassembler
0000104C  0C02 006E                 85              CMPI.B      #lwN,D2         ;Check if D2(decision) == n
00001050  6700 032A                 86              BEQ         stp             ;Stop disassembler
00001054  6000 02DC                 87              BRA         greetErr        ;Display Error - invalid input
00001058                            88  
00001058                            89  *Prompts and processes Starting Address
00001058  4EB9 000011F2             90  procStart   JSR         clr_regs        ;Clear out data from Registers
0000105E  103C 0001                 91              MOVE.B      #task1,D0       ;D0 holds input from user
00001062  43F9 000014F0             92              LEA         stAdd,A1        ;A1 holds string asking for start
00001068  3239 0000155A             93              MOVE.W      stAddL,D1       ;D1 holds length of start string
0000106E  4E4F                      94              TRAP        #15             ;Run
00001070                            95  
00001070  103C 0002                 96              MOVE.B      #task2,D0       ;D0 holds task2(02), retrieve input
00001074  43F9 00001380             97              LEA         data1,A1        ;Storage location for input string
0000107A  4E4F                      98              TRAP        #15             ;Run
0000107C                            99  
0000107C  0C01 0000                100              CMPI.B      #00,D1          ;Compare starting addr length to 0
00001080  6F00 02C6                101              BLE         startErr        ;BLE 0 to bad String message (Addr too small)
00001084  0C01 0008                102              CMPI.B      #addrLen,D1     ;compare starting addr length to 8
00001088  6E00 02BE                103              BGT         startErr        ;BGE 0 to badstring message (Addr too big)
0000108C  4287                     104              CLR.L       D7              ;Remove data from D7
0000108E  6100 0174                105              BSR         conv_to_hex     ;Go to Hex conversion subroutine
00001092  0C06 0001                106              CMPI.B      #01,D6          ;Check if bad value flag(D6) == 1 (is set)
00001096  6700 02B0                107              BEQ         startErr        ;Branch to Bad String message (bad value flag set)
0000109A  4282                     108              CLR.L       D2              ;First clear register D2
0000109C  143C 0008                109              MOVE.B      #addrLen,D2     ;Then put value 8 in D2
000010A0  9401                     110              SUB.B       D1,D2           ;Subtract length of string from 8
000010A2  C4FC 0004                111              MULU.W      #4,D2           ;Multiply by 4 to get word
000010A6  E5AF                     112              LSL.L       D2,D7           ;Shift value calculated at D2 left, store in D7
000010A8  6100 0266                113              BSR         check_even      ;Verify by checking if even
000010AC  0C87 00002000            114              CMPI.L      #strtAddr,D7    ;compare start address and shifted address
000010B2  6D00 0294                115              BLT         startErr        ;if smaller then is a bad address
000010B6  0C87 000FFFFE            116              CMPI.L      #badStart,D7    ;Too close to highest available address, so invalid
000010BC  6C00 028A                117              BGE         startErr        ;Start is larger than end, Branch to Error
000010C0  23C7 000013BC            118              MOVE.L      D7,start_hex    ;start_hex holds valid start address in hex
000010C6  6000 0002                119              BRA         procEnd         ;Branch to procEnd for End Addr validation
000010CA                           120  
000010CA                           121  *Prompts and processes Ending Address
000010CA  1C3C 0000                122  procEnd     MOVE.B      #0,D6           ;Clear Bad Flag
000010CE  103C 0001                123              MOVE.B      #task1,D0       ;D0 holds task1, print wo CR
000010D2  43F9 0000155C            124              LEA         endAdd,A1       ;A1 holds string asking for ending address
000010D8  3239 000015D0            125              MOVE.W      endAddL,D1      ;D1 holds length of ending string
000010DE  4E4F                     126              TRAP        #15
000010E0                           127  
000010E0  103C 0002                128              MOVE.B      #task2,D0       ;D0 holds task2, get input from user
000010E4  43F9 00001394            129              LEA         data2,A1        ;Store input (as ptr) from user into A1
000010EA  4E4F                     130              TRAP        #15             ;Run
000010EC                           131  
000010EC  0C01 0000                132              CMPI.B      #00,D1          ;Compare starting addr length to 0
000010F0  6F00 0270                133              BLE         endErr          ;BLE 0 to Bad Ending Error (Addr too small)
000010F4  0C01 0008                134              CMPI.B      #addrLen,D1     ;Compare address size to D1
000010F8  6E00 0268                135              BGT         endErr          ;BGT value 8, branch to Bad Ending Error
000010FC  4287                     136              CLR.L       D7              ;Remove data from D7
000010FE  6100 0104                137              BSR         conv_to_hex     ;Go to Hex conversion subroutine
00001102  0C06 0001                138              CMPI.B      #01,D6          ;Check if bad value flag(D6) == 1 (is set)
00001106  6700 025A                139              BEQ         endErr          ;BEQ branch to Bad Ending Error
0000110A  4282                     140              CLR.L       D2              ;First clear register D2
0000110C  143C 0008                141              MOVE.B      #addrLen,D2     ;Then put value 8 in D2
00001110  9401                     142              SUB.B       D1,D2           ;Subtract length of string from 8
00001112  C4FC 0004                143              MULU.W      #4,D2           ;Multiply by 4 to get word
00001116  E5AF                     144              LSL.L       D2,D7           ;Shift value calculated at D2 left, store in D7
00001118  0C87 000FFFFF            145              CMPI.L      #endAddr,D7     ;Compare end address and shifted address
0000111E  6E00 0242                146              BGT         endErr          ;If larger than end address, branch to end error
00001122  2C39 000013BC            147              MOVE.L      start_hex,D6    ;Fill D6 with hex value of starting address
00001128  5286                     148              ADDI.L      #01,D6          ;Add 1 to starting address
0000112A  BE86                     149              CMP.L       D6,D7           ;Compare with end address
0000112C  6F00 0234                150              BLE         endErr          ;Branch to end error if less than or equal
00001130  23C7 000013C0            151              MOVE.L      D7,end_hex      ;Set end_hex to shifted address value
00001136  103C 0001                152              MOVE.B      #task1,D0       ;Get input from user
0000113A  4E75                     153              RTS
0000113C                           154  
0000113C                           155  CONTROL
0000113C                           156              ; io branches here after validating addresses
0000113C  49F9 000013BC            157              LEA         start_hex,A4    ;load addr of ptr to addr reg A4
00001142  4BF9 000013C0            158              LEA         end_hex,A5      ;load ending address to A5
00001148  2854                     159              MOVE.L      (A4),A4         ;move start address to ptr
0000114A  2415                     160              MOVE.L      (A5),D2         ;move end addr to reg
0000114C  103C 0000                161              MOVE.B      #task0,D0       ;D0 holds task2, print w CR
00001150  43F9 000013D8            162              LEA         col_template,A1 ;A1 holds error string
00001156  3239 000013EC            163              MOVE.W      c_temp_len,D1   ;D1 holds length of start error string
0000115C  4E4F                     164              TRAP        #15             ;Run
0000115E  7001                     165              MOVE.L      #1,D0           ;Set to force the buffer to clear
00001160  6100 0074                166              BSR         clrBuf          ;clear the buffer
00001164  7A0F                     167              MOVE.L      #$F,D5          ;Load for pagination simulation
00001166  4E75                     168              RTS
00001168                           169  ADDR_LOOP
00001168  0C45 0000                170              CMPI.W      #$0,D5          ;Compare to page counter
0000116C  6700 001C                171              BEQ         PAGEFULL        ;Wait for user to continue printing
00001170  4BF9 000013C0            172              LEA         end_hex,A5      ;load ending address to A5
00001176  2415                     173              MOVE.L      (A5),D2
00001178  B9D5                     174              CMPA.L      (A5),A4         ;compare mem ptr to end addr
0000117A  6E00 0020                175              BGT         EXIT_IO         ;Move to print buffer
0000117E  6100 05BE                176              BSR         OCR             ;Process next OP-Code
00001182  6100 002E                177              BSR         prtBuf          ;Print value in buffer
00001186  5305                     178              SUBI.B      #$1,D5          ;Decrement page counter
00001188  60DE                     179              BRA         ADDR_LOOP       ;Continue processing Address Range
0000118A                           180  PAGEFULL
0000118A  43F9 0000119E            181              LEA         PAGE_BUFFER,A1  ;task2 puts null at A1
00001190  103C 0002                182              MOVE.B      #task2,D0       ;D0 holds task2, wait for user
00001194  4E4F                     183              TRAP        #15             ;Run
00001196  7A0F                     184              MOVE.L      #$F,D5          ;Reload for pagination simulation
00001198  4E71                     185              NOP
0000119A  60CC                     186              BRA         ADDR_LOOP
0000119C                           187  EXIT_IO
0000119C  4E75                     188              RTS
0000119E                           189  
0000119E                           190  PAGE_BUFFER     DS.W    10
000011B2                           191  *******************************************************************************
000011B2                           192  *                            I/O Subroutines
000011B2                           193  *******************************************************************************
000011B2                           194  *******************************************************************************
000011B2                           195  *printBuf - Prints value in buffer to Console
000011B2                           196  *******************************************************************************
000011B2                           197  prtBuf
000011B2  48E7 FDF4                198              MOVEM.L     A0-A3/A5/D0-D5/D7,-(SP)
000011B6  41F9 000013EE            199              LEA         validB,A0       ;Get Buffer Start
000011BC                           200              ;LEA         validB_end,A2   ;Get End Buffer
000011BC  700E                     201              MOVEQ       #14,D0          ;display NULL terminated string at A1
000011BE                           202  prtLoop
000011BE  0C50 FFFF                203              CMPI.W      #$FFFF,(A0)
000011C2  6700 000C                204              BEQ         exitBufPrt
000011C6  3250                     205              MOVE.W      (A0),A1         ;Store word to write-out register A1
000011C8  30FC FFFF                206              MOVE.W      #$FFFF,(A0)+    ;clear word in buffer
000011CC                           207              ;MOVE.B      #4,D1           ;Length to print
000011CC  4E4F                     208              TRAP        #15             ;Print to console
000011CE  60EE                     209              BRA         prtLoop
000011D0                           210  exitBufPrt
000011D0  4CDF 2FBF                211              MOVEM.L     (SP)+,A0-A3/A5/D0-D5/D7
000011D4  4E75                     212              RTS
000011D6                           213  *******************************************************************************
000011D6                           214  *clrBuf - Fills buffer with blanks
000011D6                           215  *******************************************************************************
000011D6  41F9 000013EE            216  clrBuf      LEA         validB,A0       ;Get Buffer Start
000011DC  43F9 00001402            217              LEA         validB_end,A1   ;Get End of buffer
000011E2  B3C8                     218  clrLoop     CMPA.L      A0,A1           ;Check if we're at end address of buffer
000011E4  6D00 000A                219              BLT         exitBuf         ;End of buffer
000011E8  20FC FFFFFFFF            220              MOVE.L      #$FFFFFFFF,(A0)+ ;Write FFFF to buffer
000011EE  60F2                     221              BRA         clrLoop
000011F0  4E75                     222  exitBuf     RTS                         *return to subroutine
000011F2                           223  
000011F2                           224  *******************************************************************************
000011F2                           225  *clear_regs - Clears Out Data/Addresss Registers
000011F2                           226  *******************************************************************************
000011F2  4280                     227  clr_regs    CLR.L       D0              ;Clear out D0
000011F4  4281                     228              CLR.L       D1              ;Clear out D1
000011F6  4282                     229              CLR.L       D2              ;Clear out D2
000011F8  4283                     230              CLR.L       D3              ;Clear out D3
000011FA  4284                     231              CLR.L       D4              ;Clear out D4
000011FC  4285                     232              CLR.L       D5              ;Clear out D5
000011FE  4286                     233              CLR.L       D6              ;Clear out D6
00001200  4287                     234              CLR.L       D7              ;Clear out D7
00001202  4E75                     235              RTS
00001204                           236  
00001204                           237  *******************************************************************************
00001204                           238  * conv_to_hex - Converts an ASCII string to a hex value
00001204                           239  *******************************************************************************
00001204                           240  
00001204                           241  conv_to_hex
00001204  48E7 6400                242              MOVEM.L     D1/D2/D5,-(SP)  ;Put utility register on stack
00001208  0C01 0000                243  hex_loop    CMPI.B      #00,D1          ;If D1 is 0 done
0000120C  6700 005C                244              BEQ         h_return        ;If done exit
00001210  5301                     245              SUBI.B      #01,D1          ;Update counter
00001212  E99F                     246              ROL.L       #4,D7           ;Prepare register to take next hex
00001214  1419                     247              MOVE.B      (A1)+,D2        ;D2 holds next byte to convert
00001216  0C02 0030                248              CMPI.B      #$30,D2         ;Compare 30 to D2 if
0000121A  6D00 0046                249              BLT         badflag         ;Is ASCII is less than 30 bad
0000121E  0C02 0039                250              CMPI.B      #$39,D2         ;If equal or less than 39
00001222  6F00 0026                251              BLE         h_numconv       ;Convert a number
00001226  0C02 0040                252              CMPI.B      #$40,D2         ;If D2 is $40 invalid
0000122A  6F00 0036                253              BLE         badflag         ;Then bad and exit
0000122E  0C02 0046                254              CMPI.B      #$46,D2         ;Compare D2 to $46
00001232  6F00 0026                255              BLE         h_unconv        ;Branch to convet hex letter
00001236  0C02 0061                256              CMPI.B      #$61,D2         ;Compare D2 to $61
0000123A  6D00 0026                257              BLT         badflag         ;If less than bad and exit
0000123E  0C02 0066                258              CMPI.B      #$66,D2         ;Compare D2 to $66
00001242  6F00 000E                259              BLE         h_letconv       ;If less than or equal convert to HEX
00001246  6000 001A                260              BRA         badflag         ;If haven't coverted here, it's invalid
0000124A  0402 0030                261  h_numconv   SUBI.B      #$30,D2         ;Convert a number
0000124E  8E02                     262              OR.B        D2,D7           ;Add hex digit to D7
00001250  60B6                     263              BRA         hex_loop        ;Back to loop
00001252  0402 0057                264  h_letconv   SUBI.B      #$57,D2         ;Convert to Hex letter
00001256  8E02                     265              OR.B        D2,D7           ;Add hex digit to D7
00001258  60AE                     266              BRA         hex_loop        ;Back to loop
0000125A  0402 0037                267  h_unconv    SUBI.B      #$37,D2         ;Convert to Hex letter
0000125E  8E02                     268              OR.B        D2,D7           ;Add hex digit to D7
00001260  60A6                     269              BRA         hex_loop        ;Back to loop
00001262  1C3C 0001                270  badflag     MOVE.B      #01,D6          ;Set bad flag
00001266  6000 0002                271              BRA         h_return        ;Then exit
0000126A  4CDF 0026                272  h_return    MOVEM.L     (SP)+,D1/D2/D5  ;Pop register off stack
0000126E  4E75                     273              RTS                         ;Return from subroutine
00001270                           274  
00001270                           275  *******************************************************************************
00001270                           276  * conv_to_ascii - takes Hex value, separates into individual Hex bytes
00001270                           277  *******************************************************************************
00001270                           278  conv_to_ascii
00001270  48E7 3C00                279              MOVEM.L     D3/D4/D5/D2,-(SP)   ;Save D2 and A0
00001274  0C44 0004                280              CMPI.W      #04,D4          ;See if D4 is a long or word
00001278  6700 0036                281              BEQ         a_shift         ;If a word need to shift
0000127C  0C44 0000                282  ascii_loop  CMPI.W      #00,D4          ;Is count done
00001280  6700 0034                283              BEQ         a_return        ;If done exit subroutine
00001284  E99B                     284              ROL.L       #4,D3           ;Update D3 to next hex
00001286  2403                     285              MOVE.L      D3,D2           ;So D3 isn't corrupted
00001288  0282 0000000F            286              ANDI.L      #$0000000F,D2   ;Isolate the last 4 binary digits
0000128E  5304                     287              SUBI.B      #1,D4           ;Update counter
00001290  0C02 0009                288              CMPI.B      #$09,D2         ;Compare hex 9 and D2
00001294  6F00 0006                289              BLE         a_numconv       ;If 9 or less it's a number
00001298  6000 000A                290              BRA         a_letconv       ;Then is a letter
0000129C  0642 0030                291  a_numconv   ADDI.W      #$30,D2         ;Convert a number
000012A0  6000 000A                292              BRA         a_save          ;Now put in  memory
000012A4  0642 0037                293  a_letconv   ADDI.W      #$37,D2         ;Convert to Hex letter
000012A8  6000 0002                294              BRA         a_save          ;Now put in memory
000012AC  16C2                     295  a_save      MOVE.B      D2,(A3)+        ;Save in memory and ++
000012AE  60CC                     296              BRA         ascii_loop      ;Back to top of loop
000012B0  E19B                     297  a_shift     ROL.L       #08,D3          ;Move over 2 digits
000012B2  E19B                     298              ROL.L       #08,D3          ;Move over 2 digits
000012B4  60C6                     299              BRA         ascii_loop      ;Start the loop
000012B6                           300  a_return
000012B6  16FC 0000                301              MOVE.B      #$00,(A3)+      ; push NULL value to buffer
000012BA  4CDF 003C                302              MOVEM.L     (SP)+,D3/D4/D5/D2  ;Pop off stack
000012BE  4E75                     303              RTS
000012C0                           304  
000012C0                           305  *******************************************************************************
000012C0                           306  *send_addr_buf - Sends an Address Register to the Buffer
000012C0                           307  *******************************************************************************
000012C0                           308  send_addr_buf
000012C0  48E7 E474                309              MOVEM.L     D0-D2/D5/A1-A3/A5,-(SP) ;Send Registers to Stack
000012C4  43F9 00001438            310              LEA         addr_regs,A1            ;Load Address Registers
000012CA  0240 00FF                311              ANDI.W      #$00FF,D0               ;Mask Most Significant Bits
000012CE  C0FC 0003                312              MULU.W      #3,D0                   ;Calculate Offset
000012D2  43F1 0000                313              LEA         (A1,D0.W),A1            ;Get Index including Offset
000012D6  3CC9                     314              MOVE.W      A1,(A6)+
000012D8  4CDF 2E27                315              MOVEM.L     (SP)+,D0-D2/D5/A1-A3/A5 ;Restore Stack to Registers
000012DC  4E75                     316              RTS                                 ;Return
000012DE                           317  
000012DE                           318  *******************************************************************************
000012DE                           319  *send_data_buf - Sends a Data Register to the Buffer
000012DE                           320  *******************************************************************************
000012DE                           321  send_data_buf
000012DE  48E7 E474                322              MOVEM.L     D0-D2/D5/A1-A3/A5,-(SP)  ;Send Registers to Stack
000012E2  43F9 00001450            323              LEA         data_regs,A1    ;Load Data Registers
000012E8  0240 00FF                324              ANDI.W      #$00FF,D0       ;Mask Most Significant Bits
000012EC  C0FC 0003                325              MULU.W      #3,D0           ;Calculate Offset
000012F0  43F1 0000                326              LEA         (A1,D0.W),A1    ;Get Index including Offset starting at D0
000012F4  3CC9                     327              MOVE.W      A1,(A6)+
000012F6                           328  done
000012F6  4CDF 2E27                329              MOVEM.L     (SP)+,D0-D2/D5/A1-A3/A5  ;Restore Stack to Registers
000012FA  4E75                     330              RTS         ;Return
000012FC                           331  
000012FC                           332  *******************************************************************************
000012FC                           333  *send_byte_buf - Tests and sends a byte within a Register to the Buffer
000012FC                           334  *******************************************************************************
000012FC                           335  send_byte_buf
000012FC  0C40 0008                336              CMPI        #8,D0           ;Determine if is a Data or Addr Register
00001300  6D00 000A                337              BLT         isdatareg       ;Branch if is in fact a Data Reg
00001304  5140                     338              SUBI        #8,D0           ;Address Register, need to shrink
00001306  61B8                     339              BSR         send_addr_buf   ;Branch to Send Addr Register to Buffer
00001308  6000 0004                340              BRA         byte_buf_done   ;Branch to Exit
0000130C                           341  
0000130C  61D0                     342  isdatareg   BSR         send_data_buf   ;Branch to Send Data Register to Buffer
0000130E                           343  
0000130E                           344  byte_buf_done
0000130E  4E75                     345              RTS                         ;Return
00001310                           346  
00001310                           347  *******************************************************************************
00001310                           348  *check_even - Checks if Hex address is even
00001310                           349  *******************************************************************************
00001310                           350  check_even
00001310  48E7 2000                351              MOVEM.L     D2,-(SP)        ;Put utility register on stack
00001314  2407                     352              MOVE.L      D7,D2           ;Move D7 to D2
00001316  0282 00000001            353              ANDI.L      #evenAnd,D2     ;And $00000001 with D2
0000131C  0C82 00000000            354              CMPI.L      #00,D2          ;If D2 is 0 then value was odd
00001322  6700 0008                355              BEQ         even            ;If D2 equals 0 it was even
00001326  5287                     356              ADDI.L      #01,D7          ;If was odd add one to D7
00001328  6000 0002                357              BRA         even            ;Done
0000132C  4CDF 0004                358  even        MOVEM.L (SP)+,D2            ;Pop resister off stack
00001330  4E75                     359              RTS                         ;Return from subroutine
00001332                           360  
00001332                           361  ****************************** IO Errors **************************************
00001332                           362  
00001332  103C 0000                363  greetErr    MOVE.B      #task0,D0       ;D0 holds task2(02), print w CR
00001336  43F9 0000169E            364              LEA         iError,A1       ;A1 holds error string
0000133C  3239 000016EA            365              MOVE.W      iErrorL,D1      ;D1 holds length of start error string
00001342  4E4F                     366              TRAP        #15
00001344  6000 FCCE                367              BRA         Greeting        ;Branch back to Greeting
00001348                           368  
00001348  1C3C 0000                369  startErr    MOVE.B      #0,D6           ;Reset bad flag
0000134C  103C 0000                370              MOVE.B      #task0,D0       ;D0 holds task2, print w CR
00001350  43F9 000015D2            371              LEA         stError,A1      ;A1 holds error string
00001356  3239 00001628            372              MOVE.W      stErrorL,D1     ;D1 holds length of start error string
0000135C  4E4F                     373              TRAP        #15
0000135E  6000 FCF8                374              BRA         procStart       ;Back to start sequence for reprompt
00001362                           375  
00001362  1C3C 0000                376  endErr      MOVE.B      #0,D6           ;Reset bad flag
00001366  103C 0000                377              MOVE.B      #task0,D0       ;D0 holds task2, print w CR
0000136A  43F9 0000162A            378              LEA         endError,A1     ;A1 holds error string
00001370  3239 0000169C            379              MOVE.W      endErrorL,D1    ;D1 holds length of start error string
00001376  4E4F                     380              TRAP        #15
00001378  6000 FD50                381              BRA         procEnd         ;Back to end sequence for repromp
0000137C                           382  
0000137C  4E72 2700                383  stp     STOP        #$2700      *back to simulator
00001380                           384  
00001380                           385  **************************** IO Variables *************************************
00001380                           386  data1               DS.B        20              ;Where Starting Address is stored
00001394                           387  data2               DS.B        20              ;Where Ending Address is stored
000013A8                           388  decision            DS.B        20              ;to hold User's Response
000013BC                           389  start_hex           DS.L        1               ;Starting Value in Hex
000013C0                           390  end_hex             DS.L        1               ;Ending Value in Hex
000013C4                           391  dataSt              DS.B        20              ;Continue Conditional Response
000013D8= 0D 0A 4F 50 2D 43 ...    392  col_template        DC.B        CR,LF,'OP-CODE    OPERAND'
000013EC= 0014                     393  c_temp_len          DC.W        20              ;Length of Column Template
000013EE                           394  
000013EE                           395  validB              DS.B        20              ;20 Bytes for valid buffer
00001402                           396  validB_end                                      ;Used for address index
00001402  =00000014                397  validB_len          EQU         20
00001402                           398  invalidB            DS.B        20              ;80 Bytes for invalid buffer
00001416                           399  invalidB_end                                    ;Used for address index
00001416  =00000014                400  invalidB_len        EQU         20
00001416                           401  temp                DS.B        30              ;30 bytes for instructions
00001434= 0D                       402  carr_ret            DC.B        CR
00001435= 01                       403  carr_retLen         DC.B        1
00001436= 0A                       404  linefeed            DC.B        LF
00001437= 01                       405  linefeedLen         DC.B        1
00001438                           406  ;addr_regs           DC.B    'A0','A1','A2','A3','A4','A5','A6','A7'
00001438                           407  ;data_regs           DC.B    'D0','D1','D2','D3','D4','D5','D6','D7'
00001438                           408  
00001438                           409  ADDR_REGS
00001438= 41 30 00                 410  _A0                 DC.B        'A0',0
0000143B= 41 31 00                 411  _A1                 DC.B        'A1',0
0000143E= 41 32 00                 412  _A2                 DC.B        'A2',0
00001441= 41 33 00                 413  _A3                 DC.B        'A3',0
00001444= 41 34 00                 414  _A4                 DC.B        'A4',0
00001447= 41 35 00                 415  _A5                 DC.B        'A5',0
0000144A= 41 36 00                 416  _A6                 DC.B        'A6',0
0000144D= 41 37 00                 417  _A7                 DC.B        'A7',0
00001450                           418  
00001450                           419  DATA_REGS
00001450= 44 30 00                 420  _D0                 DC.B        'D0',0
00001453= 44 31 00                 421  _D1                 DC.B        'D1',0
00001456= 44 32 00                 422  _D2                 DC.B        'D2',0
00001459= 44 33 00                 423  _D3                 DC.B        'D3',0
0000145C= 44 34 00                 424  _D4                 DC.B        'D4',0
0000145F= 44 35 00                 425  _D5                 DC.B        'D5',0
00001462= 44 36 00                 426  _D6                 DC.B        'D6',0
00001465= 44 37 00                 427  _D7                 DC.B        'D7',0
00001468                           428  
00001468                           429  ************************ IO Prompts and Messages*******************************
00001468                           430  ascii_w              DS.W        10
0000147C                           431  ASCII_IMMEDIATE      DS.W        10
00001490= 0D 0A 53 61 42 20 ...    432  greet       DC.B        CR,LF,'SaB Disassembler - CSS 422 Winter',CR,LF
000014B5= 53 74 61 72 74 20 ...    433              DC.B        'Start Disassembler?',CR,LF
000014CA= 50 6C 65 61 73 65 ...    434              DC.B        'Please enter Y for yes, or N for no.'
000014EE= 0079                     435  greetL      DC.W        121
000014F0                           436  
000014F0= 50 6C 65 61 73 65 ...    437  stAdd       DC.B        'Please enter a Starting Address',CR,LF
00001511= 73 74 61 72 74 20 ...    438              DC.B        'start address must be larger than $00002000 and smaller than $000FFFFF',CR,LF
0000155A= 0069                     439  stAddL      DC.W        105
0000155C                           440  
0000155C= 50 6C 65 61 73 65 ...    441  endAdd      DC.B        'Please enter an Ending Address.',CR,LF
0000157D= 41 64 64 72 65 73 ...    442              DC.B        'Address must be below $000FFFFF and at least 1 word larger than Starting Address',CR,LF
000015D0= 0073                     443  endAddL     DC.W        115
000015D2                           444  
000015D2= 49 6E 76 61 6C 69 ...    445  stError     DC.B        'Invalid Starting Address',CR,LF
000015EC= 73 74 61 72 74 20 ...    446              DC.B        'start address must be above $00002000',CR,LF
00001613= 61 6E 64 20 62 65 ...    447              DC.B        'and below $000FFFFF',CR,LF
00001628= 0056                     448  stErrorL    DC.W        86
0000162A                           449  
0000162A= 49 6E 76 61 6C 69 ...    450  endError    DC.B        'Invalid End address',CR,LF
0000163F= 65 6E 64 20 61 64 ...    451              DC.B        'end address must be at least one word larger than start address',CR,LF
00001680= 61 6E 64 20 73 6D ...    452              DC.B        'and smaller than $000FFFFF',CR,LF
0000169C= 0072                     453  endErrorL   DC.W        114
0000169E                           454  
0000169E= 59 6F 75 20 65 6E ...    455  iError      DC.B        'You entered an invalid value, it must be the letter',CR,LF
000016D3= 59 20 66 6F 72 20 ...    456              DC.B        'Y for yes or N for no',CR,LF
000016EA= 0059                     457  iErrorL     DC.W        89
000016EC                           458  
000016EC= 0D 0A 43 6F 6E 74 ...    459  conti       DC.B        CR,LF,'Continue using Disassembler?',CR,LF
0000170C= 50 6C 65 61 73 65 ...    460              DC.B        'Please enter Y for yes, or N for no',CR,LF
00001732= 0045                     461  contiL      DC.W        69
00001734                           462  
00001734                           463  *******************************************************************************
00001734                           464  *                               End I/O Routine
00001734                           465  *******************************************************************************
00001734                           466  
00001734                           467  *******************************************************************************
00001734                           468  */////////////////////////////////////////////////////////////////////////////*
00001734                           469  *                               Op-Code Routine                               *
00001734                           470  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
00001734                           471  *******************************************************************************
00001734                           472  
00001734                           473  * --Receive a pointer to the op-code word in memory, a pointer to the next
00001734                           474  *   available space in the buffer, and a good/bad flag (bool bit) from the I/O
00001734                           475  *   routine
00001734                           476  * --The Word data at the specified address is moved to Data register
00001734                           477  * --Move bits from the word to separate data registers for comparison, and/or
00001734                           478  *   employ some form of bit masking, shifting, or rolling.
00001734                           479  * --If Word cannot be decoded to a matching op-code, set some kind of bool
00001734                           480  *   flag/bit and return to I/O
00001734                           481  * --If Word can be decoded, then prepare ASCII string to return to I/O
00001734                           482  * --Send 6 bits from the EA field of the op-code word, a pointer to the
00001734                           483  *   next word after the op-code Word, and a good/bad flag (bool bit) to the
00001734                           484  *   EA routine
00001734                           485  * --Receive a pointer to the next word after the EA word, a pointer to next
00001734                           486  *   available space in the buffer, and a good/bad flag (bool bit) from the EA
00001734                           487  *   routine
00001734                           488  * --Send a memory pointer to the next op-code word and a good/bad flag
00001734                           489  *   (bool bit) to I/O routine
00001734                           490  
00001734                           491  *******************************************************************************
00001734                           492  
00001734                           493  **Notes for routine**
00001734                           494  * --Registers are arbitrary, but all register states except the register used
00001734                           495  *   for the pointer to the op-code word (A0 for now) should be saved prior to
00001734                           496  *   op-code routine anyway
00001734                           497  * --Universal buffer needs to be established
00001734                           498  * --bool bit, still not sure which register to use
00001734                           499  * --OCR = Op-code routine
00001734                           500  * --JSR OCR is a temporary call, remove when I/O actual utilizes subroutine
00001734                           501  ASCII_OPCODE_ADDRESS        DS.W        5
0000173E                           502  
0000173E                           503  OCR ; subroutine called by I/O
0000173E  48E7 FFF4                504              MOVEM.L     A0-A3/A5/D0-D7,-(SP)
00001742  6100 FAAE                505              BSR         CLR_REGS   ; clear registers D0-D7, start fresh
00001746  4DF8 13EE                506              LEA         validB,A6  ; load pointer to good buffer into A6
0000174A  321C                     507              MOVE.W      (A4)+,D1   ; A4, universal ptr to next op-code mem addr
0000174C                           508  
0000174C  47F8 1734                509              LEA         ASCII_OPCODE_ADDRESS,A3
00001750  2601                     510              MOVE.L      D1,D3               ;Back up to D3
00001752  7804                     511              MOVEQ       #4,D4
00001754  6100 FB1A                512              BSR         conv_to_ascii       ;Branch to convert to ASCII
00001758                           513  
00001758                           514              *Store Hex Address to Buffer
00001758  3CFC 1734                515              MOVE.W      #ASCII_OPCODE_ADDRESS,(A6)+  ;Add to buffer
0000175C  3CFC 219A                516              MOVE.W      #TAB_SIGN,(A6)+     ; Insert tab to print buffer
00001760                           517  
00001760                           518                                     ; D1 holds original op-code word until
00001760                           519                                     ; routine is finished
00001760  7003                     520              MOVEQ       #3,D0                   ; Iso-task 3: isolate d12-d15
00001762  6100 0466                521              BSR         ISO_BITS
00001766                           522  
00001766                           523              ;LEA            LOCAL,A1
00001766                           524              ;MULU       #4,D2
00001766                           525              ;JMP            00(A1,D2)
00001766                           526  ;LOCAL;
00001766                           527              ;BRA         ORI_ANDI_SUBI_ADDI_EORI_CMPI ; ORI,ANDI,SUBI,EORI,CMPI
00001766                           528              ;BRA         MOVE_MOVEA              ; MOVE, MOVEA
00001766                           529              ;BRA         MOVE_MOVEA              ; MOVE, MOVEA
00001766                           530              ;BRA         MOVE_MOVEA              ; MOVE, MOVEA
00001766                           531              ;BRA         NEG_NOP_RTS_JSR_JMP     ; NEG, NOP, RTS, JSR, JMP
00001766                           532              ;BRA         ADDQ_                   ; ADDQ
00001766                           533              ;BRA         B_                      ; Bcc
00001766                           534              ;BRA         DATA                    ; value not recognized
00001766                           535              ;BRA         OR_                     ; OR
00001766                           536              ;BRA         SUBA_                   ; SUBA
00001766                           537              ;BRA         DATA                    ; value not recognized
00001766                           538              ;BRA         EOR_CMP_CMPA            ; EOR, CMP, CMPA
00001766                           539              ;BRA         AND_                    ; AND
00001766                           540              ;BRA         ADDA_                   ; ADDA
00001766                           541              ;BRA         ASd_ROd                 ; ASd, ROd
00001766                           542              ;BRA         DATA                    ; value not recognized
00001766                           543  
00001766  B43C 0000                544              CMP.B       #0,D2
0000176A  6700 0060                545              BEQ         ORI_ANDI_SUBI_ADDI_EORI_CMPI ; ORI,ANDI,SUBI,EORI,CMPI
0000176E  B43C 0003                546              CMP.B       #3,D2
00001772  6F00 0110                547              BLE         MOVE_MOVEA              ; MOVE, MOVEA
00001776  B43C 0004                548              CMP.B       #4,D2
0000177A  6700 0156                549              BEQ         NEG_NOP_RTS_JSR_JMP     ; NEG, NOP, RTS, JSR, JMP
0000177E  B43C 0005                550              CMP.B       #5,D2
00001782  6700 01EA                551              BEQ         ADDQ_                   ; ADDQ
00001786  B43C 0006                552              CMP.B       #6,D2
0000178A  6700 01F8                553              BEQ         B_                      ; Bcc
0000178E  B43C 0008                554              CMP.B       #8,D2
00001792  6700 0254                555              BEQ         OR_                     ; OR
00001796  B43C 0009                556              CMP.B       #9,D2
0000179A  6700 0262                557              BEQ         SUBA_                   ; SUBA
0000179E  B43C 000B                558              CMP.B       #11,D2
000017A2  6700 027C                559              BEQ         EOR_CMP_CMPA            ; EOR, CMP, CMPA
000017A6  B43C 000C                560              CMP.B       #12,D2
000017AA  6700 02EE                561              BEQ         AND_                    ; AND
000017AE  B43C 000D                562              CMP.B       #13,D2
000017B2  6700 02FC                563              BEQ         ADDA_                   ; ADDA
000017B6  B43C 000E                564              CMP.B       #14,D2
000017BA  6700 0316                565              BEQ         ASd_ROd                 ; ASd, ROd
000017BE  6000 0402                566              BRA         DATA                    ; value not recognized
000017C2                           567  END_OCR
000017C2                           568              ; end of routine, reload registers
000017C2  3CFC 1E3C                569              MOVE.W      #NEW_LINE,(A6)+         ; append to the end of every op
000017C6  4CDF 2FFF                570              MOVEM.L     (SP)+,A0-A3/A5/D0-D7
000017CA  4E75                     571              RTS                                 ; return to I/O
000017CC                           572  
000017CC                           573  ************************ ORI, ANDI, SUBI, EORI, CMPI **************************
000017CC                           574  ORI_ANDI_SUBI_ADDI_EORI_CMPI
000017CC  7002                     575              MOVEQ       #2,D0                   ; Iso-task 2: isolate d9-d11
000017CE  6100 03FA                576              BSR         ISO_BITS
000017D2                           577                                                  **Branches**
000017D2  B43C 0000                578              CMP.B       #0,D2
000017D6  6700 002E                579              BEQ         ORI_                    ; ORI
000017DA  B43C 0001                580              CMP.B       #1,D2
000017DE  6700 003A                581              BEQ         ANDI_                   ; ANDI
000017E2  B43C 0002                582              CMP.B       #2,D2
000017E6  6700 0046                583              BEQ         SUBI_                   ; SUBI
000017EA  B43C 0003                584              CMP.B       #3,D2
000017EE  6700 0052                585              BEQ         ADDI_                   ; ADDI
000017F2  B43C 0005                586              CMP.B       #5,D2
000017F6  6700 0060                587              BEQ         EORI_                   ; EORI
000017FA  B43C 0006                588              CMP.B       #6,D2
000017FE  6700 006E                589              BEQ         CMPI_                   ; CMPI
00001802  6000 03BE                590              BRA         DATA                    ; value not recognized
00001806                           591  
00001806                           592  ************************************* ORI *************************************
00001806                           593  ORI_
00001806  3CFC 1DBA                594              MOVE.W      #_ORI,(A6)+     ; push address of ORI to buffer
0000180A  7001                     595              MOVEQ       #1,D0           ; Iso-task 1: isolate bits d6-d7
0000180C  6100 03BC                596              BSR         ISO_BITS
00001810  6100 047A                597              BSR         BWL             ; append .B, .W, or .L
00001814  6100 050C                598              BSR         IMMEDIATE_ADDR
00001818  60A8                     599              BRA         END_OCR
0000181A                           600  
0000181A                           601  ************************************ ANDI *************************************
0000181A                           602  ANDI_
0000181A  3CFC 1DBE                603              MOVE.W      #_ANDI,(A6)+        ; push address of ANDI to buffer
0000181E  7001                     604              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001820  6100 03A8                605              BSR         ISO_BITS
00001824  6100 0466                606              BSR         BWL                 ; append .B, .W, or .L
00001828  6100 04F8                607              BSR         IMMEDIATE_ADDR
0000182C  6094                     608              BRA         END_OCR
0000182E                           609  
0000182E                           610  ************************************ SUBI *************************************
0000182E                           611  SUBI_
0000182E  3CFC 1DC3                612              MOVE.W      #_SUBI,(A6)+        ; push address of SUBI to buffer
00001832  7001                     613              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001834  6100 0394                614              BSR         ISO_BITS
00001838  6100 0452                615              BSR         BWL                 ; append .B, .W, or .L
0000183C  6100 04E4                616              BSR         IMMEDIATE_ADDR
00001840  6080                     617              BRA         END_OCR
00001842                           618  
00001842                           619  ************************************ ADDI *************************************
00001842                           620  ADDI_
00001842  3CFC 1DC8                621              MOVE.W      #_ADDI,(A6)+        ; push address of ADDI to buffer
00001846  7001                     622              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001848  6100 0380                623              BSR         ISO_BITS
0000184C  6100 043E                624              BSR         BWL                 ; append .B, .W, or .L
00001850  6100 04D0                625              BSR         IMMEDIATE_ADDR
00001854  6000 FF6C                626              BRA         END_OCR
00001858                           627  
00001858                           628  ************************************ EORI *************************************
00001858                           629  EORI_
00001858  3CFC 1DCD                630              MOVE.W      #_EORI,(A6)+        ; push address of EORI to buffer
0000185C  7001                     631              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
0000185E  6100 036A                632              BSR         ISO_BITS
00001862  6100 0428                633              BSR         BWL                 ; append .B, .W, or .L
00001866  6100 04BA                634              BSR         IMMEDIATE_ADDR
0000186A  6000 FF56                635              BRA         END_OCR
0000186E                           636  
0000186E                           637  ************************************ CMPI *************************************
0000186E                           638  CMPI_
0000186E  3CFC 1DD2                639              MOVE.W      #_CMPI,(A6)+        ; push address of CMPI to buffer
00001872  7001                     640              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001874  6100 0354                641              BSR         ISO_BITS
00001878  6100 0412                642              BSR         BWL                 ; append .B, .W, or .L
0000187C  6100 04A4                643              BSR         IMMEDIATE_ADDR
00001880  6000 FF40                644              BRA         END_OCR
00001884                           645  
00001884                           646  ******************************** MOVE, MOVEA **********************************
00001884                           647  MOVE_MOVEA
00001884  7001                     648              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001886  6100 0342                649              BSR         ISO_BITS
0000188A  B43C 0001                650              CMP.B       #1,D2
0000188E  6700 0006                651              BEQ         MOVEA_
00001892  6000 0020                652              BRA         MOVE_
00001896                           653  
00001896                           654  *********************************** MOVEA *************************************
00001896                           655  MOVEA_
00001896  3CFC 1DDC                656              MOVE.W      #_MOVEA,(A6)+        ; push address of MOVEA to buffer
0000189A  7003                     657              MOVEQ       #3,D0               ; Iso-task 3: isolate d12-d15
0000189C  6100 032C                658              BSR         ISO_BITS
000018A0  6100 0416                659              BSR         BLW                 ; append .B, .W, or .L
000018A4                           660  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
000018A4  6100 0366                661              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
000018A8  6100 0384                662              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
000018AC  6100 0592                663              BSR         EAR_decode          ; call EA subroutine
000018B0  6000 FF10                664              BRA         END_OCR
000018B4                           665  
000018B4                           666  ************************************ MOVE *************************************
000018B4                           667  MOVE_
000018B4  3CFC 1DD7                668              MOVE.W      #_MOVE,(A6)+        ; push address of MOVE to buffer
000018B8  7003                     669              MOVEQ       #3,D0               ; Iso-task 3: isolate d12-d15
000018BA  6100 030E                670              BSR         ISO_BITS
000018BE  6100 03F8                671              BSR         BLW                 ; append .B, .W, or .L
000018C2                           672  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
000018C2  6100 0348                673              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
000018C6  6100 0366                674              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
000018CA  6100 0574                675              BSR         EAR_decode          ; call EA subroutine
000018CE  6000 FEF2                676              BRA         END_OCR
000018D2                           677  
000018D2                           678  ************************** NEG, NOP, RTS, JSR, JMP ****************************
000018D2                           679  NEG_NOP_RTS_JSR_JMP
000018D2  7002                     680              MOVEQ       #2,D0               ; Iso-task 2: isolate d9-d11
000018D4  6100 02F4                681              BSR         ISO_BITS
000018D8                           682                                              **Branches**
000018D8  B43C 0002                683              CMP.B       #2,D2
000018DC  6700 000E                684              BEQ         NEG_                ; NEG
000018E0  B43C 0007                685              CMP.B       #7,D2
000018E4  6700 001C                686              BEQ         NOP_RTS_JSR_JMP     ; NOP, RTS, JSR, JMP
000018E8  6000 02D8                687              BRA         DATA                ; value not recognized
000018EC                           688  
000018EC                           689  ************************************* NEG *************************************
000018EC                           690  NEG_
000018EC  3CFC 1DE2                691              MOVE.W      #_NEG,(A6)+         ; push address of NEG to buffer
000018F0  7001                     692              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
000018F2  6100 02D6                693              BSR         ISO_BITS
000018F6  6100 0394                694              BSR         BWL                 ; append .B, .W, or .L
000018FA  6100 0310                695              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
000018FE  6000 FEC2                696              BRA         END_OCR
00001902                           697  
00001902                           698  ***************************** NOP, RTS, JSR, JMP ******************************
00001902                           699  NOP_RTS_JSR_JMP
00001902  7001                     700              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001904  6100 02C4                701              BSR         ISO_BITS
00001908                           702  
00001908  B43C 0001                703              CMP.B       #1,D2
0000190C  6700 0016                704              BEQ         NOP_RTS             ; NOP, RTS
00001910  B43C 0002                705              CMP.B       #2,D2
00001914  6700 0038                706              BEQ         JSR_                ; JSR
00001918  B43C 0003                707              CMP.B       #3,D2
0000191C  6700 0040                708              BEQ         JMP_                ; JMP
00001920  6000 02A0                709              BRA         DATA                ; value not recognized
00001924                           710  
00001924                           711  ********************************** NOP, RTS ***********************************
00001924                           712  NOP_RTS
00001924  7000                     713              MOVEQ       #0,D0               ; Iso-task 0: isolate d0-d5
00001926  6100 02A2                714              BSR         ISO_BITS
0000192A  B43C 0031                715              CMP.B       #$31,D2
0000192E  6700 000E                716              BEQ         NOP_                ; NOP
00001932  B43C 0035                717              CMP.B       #$35,D2
00001936  6700 000E                718              BEQ         RTS_                ; RTS
0000193A  6000 0286                719              BRA         DATA                ; value not recognized
0000193E                           720  
0000193E                           721  ************************************ NOP **************************************
0000193E                           722  NOP_
0000193E  3CFC 1DE6                723              MOVE.W      #_NOP,(A6)+         ; push address of NOP to buffer
00001942  6000 FE7E                724              BRA         END_OCR
00001946                           725  
00001946                           726  ************************************ RTS **************************************
00001946                           727  RTS_
00001946  3CFC 1DEA                728              MOVE.W      #_RTS,(A6)+         ; push address of RTS to buffer
0000194A  6000 FE76                729              BRA         END_OCR
0000194E                           730  
0000194E                           731  ************************************ JSR **************************************
0000194E                           732  JSR_
0000194E  3CFC 1DEE                733              MOVE.W      #_JSR,(A6)+             ; push address of JSR to buffer
00001952  3CFC 1DAE                734              MOVE.W      #SPACING,(A6)+          ; even column spacing
00001956  6100 02B4                735              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
0000195A  6000 FE66                736              BRA         END_OCR
0000195E                           737  
0000195E                           738  ************************************ JMP **************************************
0000195E                           739  JMP_
0000195E  3CFC 1DF2                740              MOVE.W      #_JMP,(A6)+             ; push address of JMP to buffer
00001962  3CFC 1DAE                741              MOVE.W      #SPACING,(A6)+          ; even column spacing
00001966  6100 02A4                742              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
0000196A  6000 FE56                743              BRA         END_OCR
0000196E                           744  
0000196E                           745  ************************************ ADDQ *************************************
0000196E                           746  ADDQ_
0000196E  3CFC 1DF6                747              MOVE.W      #_ADDQ,(A6)+        ; push address of ADDQ to buffer
00001972  7001                     748              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001974  6100 0254                749              BSR         ISO_BITS
00001978  6100 0312                750              BSR         BWL                 ; append .B, .W, or .L
0000197C  6100 028E                751              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001980  6000 FE40                752              BRA         END_OCR
00001984                           753  
00001984                           754  ************************************ Bcc **************************************
00001984                           755  B_
00001984  7005                     756              MOVEQ       #5,D0               ; Iso-task 1: isolate bits d6-d7
00001986  6100 0242                757              BSR         ISO_BITS
0000198A                           758                                              **BRANCH**
0000198A  B43C 0004                759              CMP.B       #4,D2
0000198E  6700 0026                760              BEQ         BCC_                ; BCC
00001992  B43C 0005                761              CMP.B       #5,D2
00001996  6700 0028                762              BEQ         BCS_                ; BCS
0000199A  B43C 0007                763              CMP.B       #7,D2
0000199E  6700 002A                764              BEQ         BEQ_                ; BEQ
000019A2  B43C 0008                765              CMP.B       #8,D2
000019A6  6700 002C                766              BEQ         BVC_                ; BVC
000019AA  B43C 0009                767              CMP.B       #9,D2
000019AE  6700 002E                768              BEQ         BVS_                ; BVS
000019B2  6000 020E                769              BRA         DATA                ; value not recognized
000019B6                           770  
000019B6                           771  BCC_
000019B6  3CFC 1DFB                772              MOVE.W      #_BCC,(A6)+         ; push address of BCC to buffer
000019BA  341C                     773              MOVE.W      (A4)+,D2
000019BC  6000 FE04                774              BRA         END_OCR
000019C0                           775  BCS_
000019C0  3CFC 1DFF                776              MOVE.W      #_BCS,(A6)+         ; push address of BCS to buffer
000019C4  341C                     777              MOVE.W      (A4)+,D2
000019C6  6000 FDFA                778              BRA         END_OCR
000019CA                           779  BEQ_
000019CA  3CFC 1E03                780              MOVE.W      #_BEQ,(A6)+         ; push address of BEQ to buffer
000019CE  341C                     781              MOVE.W      (A4)+,D2
000019D0  6000 FDF0                782              BRA         END_OCR
000019D4                           783  BVC_
000019D4  3CFC 1E07                784              MOVE.W      #_BVC,(A6)+         ; push address of BVC to buffer
000019D8  341C                     785              MOVE.W      (A4)+,D2
000019DA  6000 FDE6                786              BRA         END_OCR
000019DE                           787  BVS_
000019DE  3CFC 1E0B                788              MOVE.W      #_BVS,(A6)+         ; push address of BVS to buffer
000019E2  341C                     789              MOVE.W      (A4)+,D2
000019E4  6000 FDDC                790              BRA         END_OCR
000019E8                           791  ************************************* OR **************************************
000019E8                           792  OR_
000019E8  3CFC 1E0F                793              MOVE.W      #_OR,(A6)+          ; push address of OR to buffer
000019EC  7001                     794              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
000019EE  6100 01DA                795              BSR         ISO_BITS
000019F2  6100 0298                796              BSR         BWL                 ; append .B, .W, or .L
000019F6  6100 034A                797              BSR         LOGIC_OP_EA
000019FA  6000 FDC6                798              BRA         END_OCR
000019FE                           799  ************************************ SUBA *************************************
000019FE                           800  SUBA_
000019FE  3CFC 1E12                801              MOVE.W      #_SUBA,(A6)+    ; push address of SUBA to buffer
00001A02  7004                     802              MOVEQ       #4,D0           ; Iso-task 4: isolate bits d8
00001A04  6100 01C4                803              BSR         ISO_BITS
00001A08  6100 029C                804              BSR         WL              ; .W or .L, use WL when isolating d8
00001A0C                           805  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
00001A0C  6100 01FE                806              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001A10  6100 021C                807              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
00001A14  C03C 000F                808              AND.B       #$0F,D0 ; EA uses D0, this masks for address register
00001A18  6100 0426                809              BSR         EAR_decode              ; call EA subroutine
00001A1C  6000 FDA4                810              BRA         END_OCR
00001A20                           811  ******************************* EOR, CMP, CMPA ********************************
00001A20                           812  EOR_CMP_CMPA
00001A20  7001                     813              MOVEQ       #1,D0           ; Iso-task 1: isolate bits d6-d7
00001A22  6100 01A6                814              BSR         ISO_BITS
00001A26                           815  
00001A26  B43C 0003                816              CMP.B       #3,D2
00001A2A  6700 0006                817              BEQ         CMPA_           ; CMPA
00001A2E  6000 0024                818              BRA         EOR_CMP         ; EOR, CMP
00001A32                           819  
00001A32                           820  ************************************ CMPA *************************************
00001A32                           821  CMPA_
00001A32  3CFC 1E1F                822              MOVE.W      #_CMPA,(A6)+    ; push address of CMPA to buffer
00001A36  7004                     823              MOVEQ       #4,D0           ; Iso-task 4: isolate bits d8
00001A38  6100 0190                824              BSR         ISO_BITS
00001A3C  6100 0268                825              BSR         WL              ; .W or .L, use WL when isolating d8
00001A40                           826  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
00001A40  6100 01CA                827              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001A44  6100 01E8                828              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
00001A48  C03C 000F                829              AND.B       #$0F,D0 ; EA uses D0, this masks for address register
00001A4C  6100 03F2                830              BSR         EAR_decode              ; call EA subroutine
00001A50  6000 FD70                831              BRA         END_OCR
00001A54                           832  ********************************** EOR, CMP ***********************************
00001A54                           833  EOR_CMP
00001A54  7004                     834              MOVEQ       #4,D0           ; Iso-task 4: isolate bits d8
00001A56  6100 0172                835              BSR         ISO_BITS
00001A5A                           836  
00001A5A  B43C 0000                837              CMP.B       #0,D2
00001A5E  6700 0006                838              BEQ         CMP_            ; CMP
00001A62  6000 0020                839              BRA         EOR_            ; EOR
00001A66                           840  
00001A66                           841  ************************************ CMP **************************************
00001A66                           842  CMP_
00001A66  3CFC 1E1B                843              MOVE.W      #_CMP,(A6)+         ; push address of CMP to buffer
00001A6A  7001                     844              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001A6C  6100 015C                845              BSR         ISO_BITS
00001A70  6100 021A                846              BSR         BWL                 ; append .B, .W, or .L
00001A74                           847  
00001A74                           848  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
00001A74  6100 0196                849              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001A78  6100 01B4                850              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
00001A7C  6100 03C2                851              BSR         EAR_decode              ; call EA subroutine
00001A80  6000 FD40                852              BRA         END_OCR
00001A84                           853  ************************************ EOR **************************************
00001A84                           854  EOR_
00001A84  3CFC 1E17                855              MOVE.W      #_EOR,(A6)+     ; push address of EOR to buffer
00001A88  7001                     856              MOVEQ       #1,D0           ; Iso-task 1: isolate bits d6-d7
00001A8A  6100 013E                857              BSR         ISO_BITS
00001A8E  6100 01FC                858              BSR         BWL             ; append .B, .W, or .L
00001A92  6100 02AE                859              BSR         LOGIC_OP_EA
00001A96  6000 FD2A                860              BRA         END_OCR
00001A9A                           861  *********************************** AND ***************************************
00001A9A                           862  AND_
00001A9A  3CFC 1E24                863              MOVE.W      #_AND,(A6)+     ; push address of AND to buffer
00001A9E  7001                     864              MOVEQ       #1,D0           ; Iso-task 1: isolate bits d6-d7
00001AA0  6100 0128                865              BSR         ISO_BITS
00001AA4  6100 01E6                866              BSR         BWL             ; append .B, .W, or .L
00001AA8  6100 0298                867              BSR         LOGIC_OP_EA
00001AAC  6000 FD14                868              BRA         END_OCR
00001AB0                           869  ************************************ ADDA *************************************
00001AB0                           870  ADDA_
00001AB0  3CFC 1E28                871              MOVE.W      #_ADDA,(A6)+    ; push address of ADDA to buffer
00001AB4  7004                     872              MOVEQ       #4,D0           ; Iso-task 4: isolate bits d8
00001AB6  6100 0112                873              BSR         ISO_BITS
00001ABA  6100 01EA                874              BSR         WL              ; .W or .L, use WL when isolating d8
00001ABE                           875  * Isolate bits d0-d5 and d6-d11, and send them to EA routine before return
00001ABE  6100 014C                876              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001AC2  6100 016A                877              BSR         ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
00001AC6  C03C 000F                878              AND.B       #$0F,D0 ; EA uses D0, this masks for address register
00001ACA  6100 0374                879              BSR         EAR_decode          ; call EA subroutine
00001ACE  6000 FCF2                880              BRA         END_OCR
00001AD2                           881  ********************************** ASd, ROd ***********************************
00001AD2                           882  ASd_ROd
00001AD2  7001                     883              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001AD4  6100 00F4                884              BSR         ISO_BITS
00001AD8  B43C 0003                885              CMP.B       #3,D2
00001ADC  6700 008A                886              BEQ         ASd_ROd_MS
00001AE0  6000 0002                887              BRA         ASd_ROd_RS
00001AE4                           888  *******************************************************************************
00001AE4                           889  ASd_ROd_RS
00001AE4  7006                     890              MOVEQ       #6,D0               ; Iso-task 6: isolate d3-d4
00001AE6  6100 00E2                891              BSR         ISO_BITS
00001AEA  B43C 0000                892              CMP.B       #0,D2
00001AEE  6700 000E                893              BEQ         ASd_RS               ; ASd
00001AF2  B43C 0003                894              CMP.B       #3,D2
00001AF6  6700 001A                895              BEQ         ROd_RS               ; ROd
00001AFA  6000 00C6                896              BRA         DATA                ; value not recognized
00001AFE                           897  
00001AFE                           898  ASd_RS
00001AFE  3CFC 1E2D                899              MOVE.W      #_ASd,(A6)+         ; push address of ASd to buffer
00001B02  6100 00A6                900              BSR         DIRECTION
00001B06  6100 00AE                901              BSR         ASd_ROd_SIZE
00001B0A  6000 0012                902              BRA         COMPLEX
00001B0E                           903  
00001B0E  6000 FCB2                904              BRA         END_OCR
00001B12                           905  
00001B12                           906  ROd_RS
00001B12  3CFC 1E30                907              MOVE.W      #_ROd,(A6)+         ; push address of ROd to buffer
00001B16  6100 0092                908              BSR         DIRECTION
00001B1A  6100 009A                909              BSR         ASd_ROd_SIZE
00001B1E                           910  
00001B1E                           911  COMPLEX
00001B1E  3CFC 219A                912              MOVE.W      #TAB_SIGN,(A6)+
00001B22  B43C 0001                913              CMP.B       #1,D2
00001B26  6700 0032                914              BEQ         ROd_WORD
00001B2A                           915  CONT_ROD_REG
00001B2A  7002                     916              MOVEQ       #2,D0
00001B2C  6100 009C                917              BSR         ISO_BITS
00001B30  1002                     918              MOVE.B      D2,D0
00001B32  6100 030C                919              BSR         EAR_DECODE
00001B36                           920  
00001B36  3CFC 217A                921              MOVE.W      #COMMA_SIGN,(A6)+     ; Insert tab to print buffer
00001B3A                           922  CONT_ROD_IND
00001B3A  7003                     923              MOVEQ       #3,D0               ; return size of source, d12-15
00001B3C  6100 008C                924              BSR         ISO_BITS
00001B40  1E02                     925              MOVE.B      D2,D7               ; store for EA
00001B42  0207 0003                926              ANDI.B      #3,D7   ; isolate to see if immediate is long or word
00001B46                           927  
00001B46  7000                     928              MOVEQ       #0,D0               ; Iso-task 0: isolate bits d0-d5
00001B48  6100 0080                929              BSR         ISO_BITS
00001B4C  0202 0007                930              ANDI.B      #7,D2
00001B50  3002                     931              MOVE.W      D2,D0               ; load to D0 (used by EA)
00001B52  6100 02EC                932              BSR         EAR_decode          ; call EA subroutine
00001B56  6000 FC6A                933              BRA         END_OCR
00001B5A                           934  ROd_WORD
00001B5A  3401                     935              MOVE.W      D1,D2
00001B5C  0802 0005                936              BTST        #5,D2
00001B60  66C8                     937              BNE         CONT_ROD_REG
00001B62  60D6                     938              BRA         CONT_ROD_IND
00001B64                           939  
00001B64  6000 FC5C                940              BRA         END_OCR
00001B68                           941  *******************************************************************************
00001B68                           942  ASd_ROd_MS
00001B68  7002                     943              MOVEQ       #2,D0       ; isolate d9-d11
00001B6A  6100 005E                944              BSR         ISO_BITS
00001B6E  B43C 0000                945              CMP.B       #0,D2       ;
00001B72  6700 000E                946              BEQ         ASd_MS
00001B76  B43C 0003                947              CMP.B       #3,D2
00001B7A  6700 001A                948              BEQ         ROd_MS
00001B7E  6000 0042                949              BRA         DATA
00001B82                           950  
00001B82                           951  ASd_MS
00001B82  3CFC 1E2D                952              MOVE.W      #_ASd,(A6)+         ; push address of ASd to buffer
00001B86  6100 0022                953              BSR         DIRECTION
00001B8A  3CFC 1DB4                954              MOVE.W      #_WORD,(A6)+
00001B8E  6100 007C                955              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001B92  6000 FC2E                956              BRA         END_OCR
00001B96                           957  ROd_MS
00001B96  3CFC 1E30                958              MOVE.W      #_ROd,(A6)+         ; push address of ROd to buffer
00001B9A  6100 000E                959              BSR         DIRECTION
00001B9E  3CFC 1DB4                960              MOVE.W      #_WORD,(A6)+
00001BA2  6100 0068                961              BSR         ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001BA6  6000 FC1A                962              BRA         END_OCR
00001BAA                           963  *******************************************************************************
00001BAA                           964  DIRECTION
00001BAA  7004                     965              MOVEQ       #4,D0               ; isolate d8
00001BAC  6100 001C                966              BSR         ISO_BITS
00001BB0  6100 0132                967              BSR         LR                  ; add left or right
00001BB4  4E75                     968              RTS
00001BB6                           969  ASd_ROd_SIZE
00001BB6  7001                     970              MOVEQ       #1,D0               ; Iso-task 1: isolate bits d6-d7
00001BB8  6100 0010                971              BSR         ISO_BITS
00001BBC  6100 00CE                972              BSR         BWL                 ; append .B, .W, or .L
00001BC0  4E75                     973              RTS
00001BC2                           974  
00001BC2                           975  *******************************************************************************
00001BC2                           976  DATA ; value not recognized
00001BC2  3CFC 1E37                977              MOVE.W      #_DATA,(A6)+         ; push address of DATA to buffer
00001BC6  6000 FBFA                978              BRA         END_OCR
00001BCA                           979  
00001BCA                           980  ************************** ISOLATE BITS SUBROUTINE ****************************
00001BCA                           981  
00001BCA                           982  ISO_BITS    ; Subroutine: Isolates bits based on the task # assigned to D0
00001BCA  B03C 0000                983              CMP.B       #0,D0       ; Task 0, isolate d0-d5
00001BCE  6700 00B4                984              BEQ         d0tod5
00001BD2  B03C 0001                985              CMP.B       #1,D0       ; Task 1, isolate d6-d7
00001BD6  6700 0098                986              BEQ         d6tod7
00001BDA  B03C 0002                987              CMP.B       #2,D0       ; Task 2, isolate d9-d11
00001BDE  6700 0072                988              BEQ         d9tod11
00001BE2  B03C 0003                989              CMP.B       #3,D0       ; Task 3, isolate d12-d15
00001BE6  6700 0056                990              BEQ         d12tod15
00001BEA  B03C 0004                991              CMP.B       #4,D0       ; Task 4, isolate d8
00001BEE  6700 006C                992              BEQ         d8
00001BF2  B03C 0005                993              CMP.B       #5,D0       ; Task 5, isolate d8-d11
00001BF6  6700 0050                994              BEQ         d8tod11
00001BFA  B03C 0006                995              CMP.B       #6,D0       ; Task 6, isolate d3-d4
00001BFE  6700 007A                996              BEQ         d3tod4
00001C02  B03C 0007                997              CMP.B       #7,D0       ; Task 7, isolate d6-d11
00001C06  6700 005E                998              BEQ         d6tod11
00001C0A  4E75                     999              RTS                     ; return to op-code branch
00001C0C                          1000  
00001C0C                          1001  ISO_D0_TO_D5_FOR_EA     ; send source <ea> bits to EAR
00001C0C  48E7 B100               1002              MOVEM.L     D0/D2/D3/D7,-(SP)
00001C10                          1003  
00001C10  7003                    1004              MOVEQ       #3,D0               ; return size of source, d12-15
00001C12  61B6                    1005              BSR         ISO_BITS
00001C14  1E02                    1006              MOVE.B      D2,D7               ; store for EA
00001C16  0207 0003               1007              ANDI.B      #3,D7   ; isolate to see if immediate is long or word
00001C1A                          1008  
00001C1A  7000                    1009              MOVEQ       #0,D0               ; Iso-task 0: isolate bits d0-d5
00001C1C  61AC                    1010              BSR         ISO_BITS
00001C1E  3002                    1011              MOVE.W      D2,D0               ; load to D0 (used by EA)
00001C20  3CFC 219A               1012              MOVE.W      #TAB_SIGN,(A6)+     ; Insert tab to print buffer
00001C24  6100 021A               1013              BSR         EAR_decode          ; call EA subroutine
00001C28                          1014  
00001C28  4CDF 008D               1015              MOVEM.L     (SP)+,D0/D2/D3/D7
00001C2C  4E75                    1016              RTS                             ; return to op-code branch
00001C2E                          1017  
00001C2E                          1018  ISO_D6_TO_D11_FOR_EA    ; send dest <ea> bits to EAR
00001C2E  7007                    1019              MOVEQ       #7,D0               ; Iso-task 7: isolate bits d6-d11
00001C30  6198                    1020              BSR         ISO_BITS
00001C32  6100 00C8               1021              BSR         SWAP_REG_MODE
00001C36  3002                    1022              MOVE.W      D2,D0               ; load iso bits to D0, used by EA
00001C38  3CFC 217A               1023              MOVE.W      #COMMA_SIGN,(A6)+   ; Insert a tab
00001C3C  4E75                    1024              RTS                             ; return to op-code branch
00001C3E                          1025  
00001C3E                          1026  d12tod15    ; Isolate bits d12-d15 and assign them to register D2
00001C3E  3401                    1027              MOVE.W      D1,D2       ; avoid overwrite of original
00001C40  E95A                    1028              ROL.W       #4,D2       ; move d12-d15 -> d0-d3
00001C42  0242 000F               1029              ANDI.W      #$F,D2      ; mask to keep only four bits
00001C46  4E75                    1030              RTS                     ; return to op-code branch
00001C48                          1031  
00001C48                          1032  d8tod11     ; Isolate bits d8-d11 and assign them to register D2
00001C48  3401                    1033              MOVE.W      D1,D2       ; avoid overwrite of original
00001C4A  E15A                    1034              ROL.W       #8,D2       ; move d8-d11 -> d0-d2
00001C4C  0242 000F               1035              ANDI.W      #$0F,D2     ; mask to keep only four bits
00001C50  4E75                    1036              RTS                     ; return to op-code branch
00001C52                          1037  
00001C52                          1038  
00001C52                          1039  d9tod11     ; Isolate bits d9-d11 and assign them to register D2
00001C52  3401                    1040              MOVE.W      D1,D2       ; avoid overwrite of original
00001C54  EF5A                    1041              ROL.W       #7,D2       ; move d9-d11 -> d0-d2
00001C56  0242 0007               1042              ANDI.W      #7,D2       ; mask to keep only three bits
00001C5A  4E75                    1043              RTS                     ; return to op-code branch
00001C5C                          1044  
00001C5C                          1045  d8          ; Isolate bits d8 and assign them to register D2
00001C5C  3401                    1046              MOVE.W      D1,D2       ; avoid overwrite of original
00001C5E  E04A                    1047              LSR.W       #8,D2       ; move d8-d11 -> d0-d2
00001C60  0242 0001               1048              ANDI.W      #1,D2       ; mask to keep only one bit
00001C64  4E75                    1049              RTS                     ; return to op-code branch
00001C66                          1050  d6tod11
00001C66  3401                    1051              MOVE.W      D1,D2       ; avoid overwrite of original
00001C68  EC4A                    1052              LSR.W       #6,D2       ; move d6-d11 -> d0-d5
00001C6A  0242 003F               1053              ANDI.W      #$3F,D2     ; mask to keep only the first six bits
00001C6E  4E75                    1054              RTS                     ; return to op-code branch
00001C70                          1055  
00001C70                          1056  d6tod7      ; Isolate bits d6-d7 and assign them to register D2
00001C70  3401                    1057              MOVE.W      D1,D2       ; avoid overwrite of original
00001C72  EC4A                    1058              LSR.W       #6,D2       ; move d6-d7 -> d0-d1
00001C74  0242 0003               1059              ANDI.W      #3,D2       ; mask to keep only two bits
00001C78  4E75                    1060              RTS                     ; return to op-code branch
00001C7A                          1061  
00001C7A                          1062  d3tod4      ; Isolate bits d0-d5 and assign them to register D2
00001C7A  3401                    1063              MOVE.W      D1,D2       ; avoid overwrite of original
00001C7C  E64A                    1064              LSR.W       #3,D2       ; move d3-d4 -> d0-d1
00001C7E  0242 0003               1065              ANDI.W      #3,D2       ; mask to keep only two bits
00001C82  4E75                    1066              RTS                     ; return to op-code branch
00001C84                          1067  
00001C84                          1068  d0tod5      ; Isolate bits d0-d5 and assign them to register D2
00001C84  3401                    1069              MOVE.W      D1,D2       ; avoid overwrite of original
00001C86  0242 003F               1070              ANDI.W      #$3F,D2     ; mask to keep only the first six bits
00001C8A  4E75                    1071              RTS                     ; return to op-code branch
00001C8C                          1072  *********************** BYTE, WORD, OR LONG SUBROUTINE ************************
00001C8C                          1073  BWL                                     ; standard sizing
00001C8C  B43C 0000               1074              CMP.B       #0,D2
00001C90  6700 0040               1075              BEQ         BYTE_
00001C94  B43C 0001               1076              CMP.B       #1,D2
00001C98  6700 003E               1077              BEQ         WORD_
00001C9C  B43C 0002               1078              CMP.B       #2,D2
00001CA0  6700 003C               1079              BEQ         LONG_
00001CA4  4E75                    1080              RTS                         ; RTS assumes that it didn't branch
00001CA6                          1081  
00001CA6                          1082  WL                                      ; used exclusively with SUBA,CMPA,ADDA
00001CA6  B43C 0000               1083              CMP.B       #0,D2
00001CAA  6700 002C               1084              BEQ         WORD_
00001CAE  B43C 0001               1085              CMP.B       #1,D2
00001CB2  6700 002A               1086              BEQ         LONG_
00001CB6  4E75                    1087              RTS                         ; RTS assumes that it didn't branch
00001CB8                          1088  
00001CB8                          1089  BLW                                     ; used exclusively with MOVE and MOVEA
00001CB8  B43C 0001               1090              CMP.B       #1,D2
00001CBC  6700 0014               1091              BEQ         BYTE_
00001CC0  B43C 0002               1092              CMP.B       #2,D2
00001CC4  6700 0018               1093              BEQ         LONG_
00001CC8  B43C 0003               1094              CMP.B       #3,D2
00001CCC  6700 000A               1095              BEQ         WORD_
00001CD0  4E75                    1096              RTS                         ; RTS assumes that it didn't branch
00001CD2                          1097  
00001CD2                          1098  BYTE_
00001CD2  3CFC 1DB1               1099              MOVE.W      #_BYTE,(A6)+    ; push address of .B to buffer
00001CD6  4E75                    1100              RTS                         ; return to subroutine that called BWL
00001CD8                          1101  
00001CD8                          1102  WORD_
00001CD8  3CFC 1DB4               1103              MOVE.W      #_WORD,(A6)+    ; push address of .W to buffer
00001CDC  4E75                    1104              RTS                         ; return to subroutine that called BWL
00001CDE                          1105  
00001CDE                          1106  LONG_
00001CDE  3CFC 1DB7               1107              MOVE.W      #_LONG,(A6)+    ; push address of .L to buffer
00001CE2  4E75                    1108              RTS                         ; return to subroutine that called BWL
00001CE4                          1109  
00001CE4                          1110  *************************** LEFT RIGHT SUBROUTINE *****************************
00001CE4                          1111  LR
00001CE4  B43C 0000               1112              CMP.B       #0,D2           ; can only be 0 or 1
00001CE8  6700 0006               1113              BEQ         RIGHT
00001CEC  6000 0008               1114              BRA         LEFT
00001CF0                          1115  
00001CF0                          1116  RIGHT
00001CF0  3CFC 1E35               1117              MOVE.W      #_RIGHT,(A6)+   ; push address of 'R' to buffer
00001CF4  4E75                    1118              RTS
00001CF6                          1119  
00001CF6                          1120  LEFT
00001CF6  3CFC 1E33               1121              MOVE.W      #_LEFT,(A6)+    ; push address of 'L' to buffer
00001CFA  4E75                    1122              RTS
00001CFC                          1123  *******************************************************************************
00001CFC                          1124  * (Semi fix for EA)
00001CFC                          1125  * Working register is D2.W
00001CFC                          1126  SWAP_REG_MODE ; called by ISO_D6_TO_D11_FOR_EA
00001CFC  48E7 1C00               1127              MOVEM.L     D3-D5,-(SP)             ; save register states
00001D00                          1128                                                  ; D2:= reg mode
00001D00  4283                    1129              CLR.L       D3                      ; D3:= reg
00001D02  4284                    1130              CLR.L       D4                      ; D4:= mode
00001D04  4285                    1131              CLR.L       D5                      ; D5:= mode reg
00001D06  3602                    1132              MOVE.W      D2,D3                   ; copy bits
00001D08  3802                    1133              MOVE.W      D2,D4                   ; copy bits
00001D0A  0243 0038               1134              ANDI.W      #%00111000,D3           ; mask for left three bits
00001D0E  0244 0007               1135              ANDI.W      #%00000111,D4           ; mask for right three bits
00001D12  E64B                    1136              LSR.W       #3,D3                   ; swap D3 bits with D4 bits
00001D14  E74C                    1137              LSL.W       #3,D4                   ; swap D4 bits with D3 bits
00001D16  8A43                    1138              OR.W        D3,D5                   ; add to D5
00001D18  8A44                    1139              OR.W        D4,D5                   ; add to D5
00001D1A  3405                    1140              MOVE.W      D5,D2                   ; move D5 to D2 (working reg.)
00001D1C  4CDF 0038               1141              MOVEM.L     (SP)+,D3-D5             ; restore register states
00001D20  4E75                    1142              RTS
00001D22                          1143  ********************** IMMEDIATE OPERATOR TO EA ROUTINE ***********************
00001D22                          1144  * Used in op-code routine to send bits to EA routine. Used with ORI, ANDI, SUBI
00001D22                          1145  * ADDI, EORI, CMPI
00001D22                          1146  IMMEDIATE_ADDR
00001D22                          1147              * SOURCE
00001D22  1E02                    1148              MOVE.B      D2,D7
00001D24  3CFC 219A               1149              MOVE.W      #TAB_SIGN,(A6)+     ; push tab to print buffer
00001D28  103C 003C               1150              MOVE.B      #$3C,D0
00001D2C  6100 0112               1151              BSR         EAR_DECODE          ; push ASCII to print buffer
00001D30  3CFC 217A               1152              MOVE.W      #COMMA_SIGN,(A6)+   ; Insert a tab
00001D34                          1153  
00001D34                          1154              * DESTINATION
00001D34  7000                    1155              MOVEQ       #0,D0               ; Iso-task 0: isolate bits d0-d5
00001D36  6100 FE92               1156              BSR         ISO_BITS
00001D3A  3002                    1157              MOVE.W      D2,D0               ; load to D0 (used by EA)
00001D3C  6100 0102               1158              BSR         EAR_DECODE
00001D40  4E75                    1159              RTS
00001D42                          1160  *********************** LOGIC OPERATOR TO EA ROUTINE **************************
00001D42                          1161  * Used in op-code routine when op-code is AND, OR, EOR, etc...
00001D42                          1162  LOGIC_OP_EA
00001D42  7004                    1163              MOVEQ       #4,D0           ; task 4: isolate d8
00001D44  6100 FE84               1164              BSR         ISO_BITS
00001D48  C4FC 0004               1165              MULU        #4,D2           ; jump setup
00001D4C                          1166  
00001D4C  43F9 00001D56           1167              LEA         LOGIC_TABLE,A1
00001D52  4EF1 2000               1168              JMP         00(A1,D2)       ; jump relative to d8
00001D56                          1169  LOGIC_TABLE
00001D56  6000 0006               1170              BRA         LOGIC_SOURCE
00001D5A  6000 001C               1171              BRA         LOGIC_DESTINATION
00001D5E                          1172  LOGIC_SOURCE
00001D5E                          1173              * SOURCE
00001D5E  6100 FEAC               1174              BSR         ISO_D0_TO_D5_FOR_EA ; send source <ea> bits to EAR
00001D62                          1175                                              ; then send destination
00001D62                          1176              * DESTINATION
00001D62  3CFC 217A               1177              MOVE.W      #COMMA_SIGN,(A6)+   ; Insert a tab
00001D66  7007                    1178              MOVEQ       #7,D0               ; Iso-task 7: isolate bits d6-d11
00001D68  6100 FE60               1179              BSR         ISO_BITS
00001D6C  618E                    1180              BSR         SWAP_REG_MODE       ; standardize format for EA
00001D6E  0242 0007               1181              ANDI.W      #7,D2               ; keep 3-bits to show which reg.
00001D72  3002                    1182              MOVE.W      D2,D0               ; load iso bits to D0, used by EA
00001D74  6000 0032               1183              BRA         END_LOGIC
00001D78                          1184  
00001D78                          1185  LOGIC_DESTINATION
00001D78                          1186              * SOURCE
00001D78  3CFC 219A               1187              MOVE.W      #TAB_SIGN,(A6)+     ; push tab to print buffer
00001D7C  7007                    1188              MOVEQ       #7,D0               ; Iso-task 7: isolate bits d6-d11
00001D7E  6100 FE4A               1189              BSR         ISO_BITS
00001D82  6100 FF78               1190              BSR         SWAP_REG_MODE       ; standardize format for EA
00001D86  0242 0007               1191              ANDI.W      #7,D2               ; keep 3-bits to show which reg.
00001D8A  3002                    1192              MOVE.W      D2,D0               ; load iso bits to D0, used by EA
00001D8C  6100 00B2               1193              BSR         EAR_DECODE          ; push ASCII to print buffer
00001D90                          1194  
00001D90                          1195              * DESTINATION
00001D90  3CFC 217A               1196              MOVE.W      #COMMA_SIGN,(A6)+   ; Insert a tab
00001D94  7003                    1197              MOVEQ       #3,D0               ; return size of source, d12-15
00001D96  6100 FE32               1198              BSR         ISO_BITS
00001D9A  1E02                    1199              MOVE.B      D2,D7               ; store for EA
00001D9C  0207 0003               1200              ANDI.B      #3,D7   ; isolate to see if immediate is long or word
00001DA0                          1201  
00001DA0  7000                    1202              MOVEQ       #0,D0               ; Iso-task 0: isolate bits d0-d5
00001DA2  6100 FE26               1203              BSR         ISO_BITS
00001DA6  3002                    1204              MOVE.W      D2,D0               ; load to D0 (used by EA)
00001DA8                          1205  
00001DA8                          1206  
00001DA8                          1207  END_LOGIC
00001DA8  6100 0096               1208              BSR         EAR_decode          ; call EA subroutine
00001DAC  4E75                    1209              RTS
00001DAE                          1210  ********************************* CONSTANTS ***********************************
00001DAE= 20 20 00                1211  SPACING     DC.B        '  ',0 ; used to give uniform column look when printing
00001DB1= 2E 42 00                1212  _BYTE       DC.B        '.B',0
00001DB4= 2E 57 00                1213  _WORD       DC.B        '.W',0
00001DB7= 2E 4C 00                1214  _LONG       DC.B        '.L',0
00001DBA= 4F 52 49 00             1215  _ORI        DC.B        'ORI',0
00001DBE= 41 4E 44 49 00          1216  _ANDI       DC.B        'ANDI',0
00001DC3= 53 55 42 49 00          1217  _SUBI       DC.B        'SUBI',0
00001DC8= 41 44 44 49 00          1218  _ADDI       DC.B        'ADDI',0
00001DCD= 45 4F 52 49 00          1219  _EORI       DC.B        'EORI',0
00001DD2= 43 4D 50 49 00          1220  _CMPI       DC.B        'CMPI',0
00001DD7= 4D 4F 56 45 00          1221  _MOVE       DC.B        'MOVE',0
00001DDC= 4D 4F 56 45 41 00       1222  _MOVEA      DC.B        'MOVEA',0
00001DE2= 4E 45 47 00             1223  _NEG        DC.B        'NEG',0
00001DE6= 4E 4F 50 00             1224  _NOP        DC.B        'NOP',0
00001DEA= 52 54 53 00             1225  _RTS        DC.B        'RTS',0
00001DEE= 4A 53 52 00             1226  _JSR        DC.B        'JSR',0
00001DF2= 4A 4D 50 00             1227  _JMP        DC.B        'JMP',0
00001DF6= 41 44 44 51 00          1228  _ADDQ       DC.B        'ADDQ',0
00001DFB= 42 43 43 00             1229  _BCC        DC.B        'BCC',0
00001DFF= 42 43 53 00             1230  _BCS        DC.B        'BCS',0
00001E03= 42 45 51 00             1231  _BEQ        DC.B        'BEQ',0
00001E07= 42 56 43 00             1232  _BVC        DC.B        'BVC',0
00001E0B= 42 56 53 00             1233  _BVS        DC.B        'BVS',0
00001E0F= 4F 52 00                1234  _OR         DC.B        'OR',0
00001E12= 53 55 42 41 00          1235  _SUBA       DC.B        'SUBA',0
00001E17= 45 4F 52 00             1236  _EOR        DC.B        'EOR',0
00001E1B= 43 4D 50 00             1237  _CMP        DC.B        'CMP',0
00001E1F= 43 4D 50 41 00          1238  _CMPA       DC.B        'CMPA',0
00001E24= 41 4E 44 00             1239  _AND        DC.B        'AND',0
00001E28= 41 44 44 41 00          1240  _ADDA       DC.B        'ADDA',0
00001E2D= 41 53 00                1241  _ASd        DC.B        'AS',0
00001E30= 52 4F 00                1242  _ROd        DC.B        'RO',0
00001E33= 4C 00                   1243  _LEFT       DC.B        'L',0
00001E35= 52 00                   1244  _RIGHT      DC.B        'R',0
00001E37= 44 41 54 41 00          1245  _DATA       DC.B        'DATA',0
00001E3C= 0D0A 0000               1246  NEW_LINE    DC.W        $0D0A,0
00001E40                          1247  
00001E40                          1248  *********************************** OTHER *************************************
00001E40  =0000000D               1249  CR          EQU         $0D
00001E40  =0000000A               1250  LF          EQU         $0A
00001E40                          1251  
00001E40                          1252  *******************************************************************************
00001E40                          1253  *                            End Op-code Routine
00001E40                          1254  *******************************************************************************
00001E40                          1255  
00001E40                          1256  *******************************************************************************
00001E40                          1257  */////////////////////////////////////////////////////////////////////////////*
00001E40                          1258  *                                   EA Routine                                *
00001E40                          1259  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
00001E40                          1260  *******************************************************************************
00001E40                          1261  
00001E40                          1262  ; --Receive 6 bits from the EA field of the op-code word, a pointer to the
00001E40                          1263  ;   next word after the op-code Word, and a good/bad flag (bool bit) from the
00001E40                          1264  ;   op-code routine
00001E40                          1265  ; --Effective address is decoded
00001E40                          1266  ; --If decode is successful/unsuccessful, set bool/bit flag appropriately
00001E40                          1267  ; --If successful, prepare ASCII string value for display
00001E40                          1268  ; --Send a memory pointer to the next word after the EA word, a pointer to the
00001E40                          1269  ;   next available space in the buffer, and a good/bad flag (bool bit) back
00001E40                          1270  ;   to op-code routine
00001E40                          1271  
00001E40                          1272  *******************************************************************************
00001E40                          1273  *EAR_decode - Decodes the EA field of the op-code word and sets the values
00001E40                          1274  *             to the buffer for the I/O to Display
00001E40                          1275  *******************************************************************************
00001E40                          1276  EAR_decode
00001E40  48E7 FDF4               1277              MOVEM.L     A0-A3/A5/D0-D5/D7,-(SP) ;Save data from registers to stack
00001E44                          1278  
00001E44  43F9 00001E62           1279              LEA         ea_index_table,A1       ;Get reference to the EA Table
00001E4A  4281                    1280              CLR.L       D1
00001E4C  3400                    1281              MOVE.W      D0,D2                   ;Get a copy of the six EA bits
00001E4E  123C 0003               1282              MOVE.B      #3,D1                   ;Store number of bits we wish to shift
00001E52  E268                    1283              LSR.W       D1,D0                   ;Shift to the Right
00001E54  C0FC 0006               1284              MULU        #6,D0                   ;Form Offset for passing to Jump Index table
00001E58  4EB1 0000               1285              JSR         00(A1,D0)               ;Now we have the index, back to Index table
00001E5C  4CDF 2FBF               1286              MOVEM.L     (SP)+,A0-A3/A5/D0-D5/D7 ;Restore registers from stack
00001E60  4E75                    1287              RTS                                 ;Return
00001E62                          1288  
00001E62                          1289  *Jump Index Table
00001E62                          1290  *Table holding the different EA Modes, will branch to different Index depending on Offset
00001E62                          1291  ea_index_table
00001E62  4EF9 00001E92           1292              JMP         eaindex000             ;Direct Data Register
00001E68  4EF9 00001E9E           1293              JMP         eaindex001             ;Direct Address Register
00001E6E  4EF9 00001EAA           1294              JMP         eaindex010             ;Indirect Address Register
00001E74  4EF9 00001EC0           1295              JMP         eaindex011             ;Indirect Address Register with Post Increment
00001E7A  4EF9 00001EDA           1296              JMP         eaindex100             ;Indirect Address Register with Pre Decrement
00001E80  4EF9 00001EF4           1297              JMP         eaindex101             ;Indirect Address Register using Index
00001E86  4EF9 00001F60           1298              JMP         eaindex110             ;Absolute or Immediate EA
00001E8C  4EF9 00001F72           1299              JMP         eaindex111             ;Not used
00001E92                          1300  
00001E92                          1301  ******* Direct Data Register - Return the Data Register to the buffer - Dn ****
00001E92                          1302  eaindex000
00001E92  3002                    1303              MOVE        D2,D0                   ;Get EA from D2 (6bits)
00001E94  0240 0007               1304              ANDI        #7,D0                   ;Grab Register (3bits)
00001E98                          1305              ;MOVE.W      #tab_sign,(A6)+         ;Insert a tab
00001E98  6100 F444               1306              BSR         send_data_buf           ;Send data to buffer
00001E9C  4E75                    1307              RTS                                 ;Return
00001E9E                          1308  
00001E9E                          1309  ***** Direct Address Register - Return the Address Register to the buffer - An
00001E9E                          1310  eaindex001
00001E9E  3002                    1311              MOVE        D2,D0                   ;Get EA from D2 (6bits)
00001EA0  0240 0007               1312              ANDI        #7,D0                   ;AND with 3bits to get Register Info
00001EA4  6100 F41A               1313              BSR         send_addr_buf          ;Send Address to buffer
00001EA8  4E75                    1314              RTS                                 ;Return
00001EAA                          1315  
00001EAA                          1316  ****** Indirect Address Register - Returns Address within Parentheses - (An) **
00001EAA                          1317  eaindex010
00001EAA                          1318              *Get the Open Paren
00001EAA  3CFC 2166               1319              MOVE.W      #OPEN_PAREN,(A6)+       ;Load close Paren to buffer
00001EAE                          1320  
00001EAE                          1321              *Get the Address
00001EAE  4280                    1322              CLR.L       D0                      ;Empty data register
00001EB0  3002                    1323              MOVE        D2,D0                   ;Store EA bits (6bits)
00001EB2  0240 0007               1324              ANDI        #7,D0                   ;AND with 3-bits to get values
00001EB6  6100 F408               1325              BSR         send_addr_buf           ;Add Address to buffer after Open Paren
00001EBA                          1326  
00001EBA                          1327              *Get the Close Paren
00001EBA  3CFC 216A               1328              MOVE.W      #CLOSE_PAREN,(A6)+      ;Load close Paren to buffer
00001EBE  4E75                    1329              RTS                                 ;Return
00001EC0                          1330  
00001EC0                          1331  ************** Indirect Address Register with Post-Increment - (An)+ **********
00001EC0                          1332  eaindex011
00001EC0                          1333              *Get the Open Paren
00001EC0  3CFC 2166               1334              MOVE.W      #OPEN_PAREN,(A6)+       ;Load close Paren to buffer
00001EC4                          1335  
00001EC4                          1336              *Get the Address
00001EC4  4280                    1337              CLR.L       D0                      ;Empty data register
00001EC6  3002                    1338              MOVE        D2,D0                   ;Store EA bits (6bits)
00001EC8  0240 0007               1339              ANDI        #7,D0                   ;AND with 3-bits to get values
00001ECC  6100 F3F2               1340              BSR         send_addr_buf           ;Add Address to buffer after Open Paren
00001ED0                          1341  
00001ED0                          1342              *Get the Close Paren
00001ED0  3CFC 216A               1343              MOVE.W      #CLOSE_PAREN,(A6)+      ;Load close Paren to buffer
00001ED4                          1344  
00001ED4                          1345              *Get the Plus Sign
00001ED4  3CFC 216E               1346              MOVE.W      #PLUS_SIGN,(A6)+                ;Add to buffer
00001ED8  4E75                    1347              RTS                                 ;Return
00001EDA                          1348  
00001EDA                          1349  *************** Indirect Address Register with Pre-Decrement - -(An) **********
00001EDA                          1350  eaindex100
00001EDA                          1351              *Get Minus Sign
00001EDA  3CFC 2172               1352              MOVE.W      #MINUS_SIGN,(A6)+                ;Add to buffer
00001EDE                          1353  
00001EDE                          1354              *Get Open Parentheses Sign
00001EDE  3CFC 2166               1355              MOVE.W      #OPEN_PAREN,(A6)+       ;Load close Paren to buffer
00001EE2                          1356  
00001EE2                          1357              *Store Address to Buffer
00001EE2  4280                    1358              CLR.L       D0                      ;Empty data register
00001EE4  3002                    1359              MOVE        D2,D0                   ;Store EA bits (6bits)
00001EE6  0240 0007               1360              ANDI        #7,D0                   ;AND with 3-bits to get values
00001EEA  6100 F3D4               1361              BSR         send_addr_buf           ;Add Address to buffer after Open Paren
00001EEE                          1362  
00001EEE                          1363              *Get Close Parentheses Sign
00001EEE  3CFC 216A               1364              MOVE.W      #CLOSE_PAREN,(A6)+      ;Load close Paren to buffer
00001EF2  4E75                    1365              RTS                                 ;Return
00001EF4                          1366  
00001EF4                          1367  ******************** Indirect Address Register with an Index ******************
00001EF4                          1368  eaindex101
00001EF4                          1369  
00001EF4                          1370              *Get Dollar Sign
00001EF4  3CFC 2176               1371              MOVE.W      #DOLLAR_SIGN,(A6)+                ;Add to buffer
00001EF8                          1372  
00001EF8                          1373              *Prep for conversion
00001EF8  305D                    1374              MOVE.W      (A5)+,A0                 ;Get 8-bit extension word
00001EFA  2600                    1375              MOVE.L      D0,D3                   ;Back up to D3
00001EFC  4284                    1376              CLR.L       D4                      ;Clear out D4
00001EFE  183C 0004               1377              MOVE.B      #4,D4                   ;Store the number of bytes (4) in D4
00001F02  6100 F36C               1378              BSR         conv_to_ascii           ;Branch to ASCII conversion Subroutine
00001F06                          1379  
00001F06                          1380              *Move Hex value to Buffer
00001F06  224B                    1381              MOVEA.L     A3,A1                   ;Move Hex value to A1
00001F08  3CC9                    1382              MOVE.W      A1,(A6)+                ;Add to buffer
00001F0A                          1383  
00001F0A                          1384              *Get Open Parentheses Sign
00001F0A  3CFC 2166               1385              MOVE.W      #OPEN_PAREN,(A6)+                ;Add to buffer
00001F0E                          1386  
00001F0E                          1387              *Store Address to Buffer
00001F0E  4280                    1388              CLR.L       D0                      ;Empty data register
00001F10  3002                    1389              MOVE        D2,D0                   ;Store EA bits (6bits)
00001F12  0240 0007               1390              ANDI        #7,D0                   ;AND with 3-bits to get values
00001F16  6100 F3A8               1391              BSR         send_addr_buf           ;Add Address to buffer after Open Paren
00001F1A                          1392  
00001F1A                          1393              *Get the Comma Sign
00001F1A  3CF9 0000217A           1394              MOVE.W      COMMA_SIGN,(A6)+                ;Add to buffer
00001F20                          1395  
00001F20                          1396              *Get Index Register
00001F20  2005                    1397              MOVE.L      D5,D0                   ;Back up to D0
00001F22  0240 F000               1398              ANDI        #$F000,D0               ;We only need the first byte, hide the rest
00001F26  E088                    1399              LSR.L       #8,D0                   ;Shift to Right-most postion
00001F28  E888                    1400              LSR.L       #4,D0                   ;Ensure it is in first bit
00001F2A  6100 F3D0               1401              BSR         send_byte_buf           ;Now store the value at this Register to buffer
00001F2E                          1402  
00001F2E                          1403              *Get the Type
00001F2E  2005                    1404              MOVE.L      D5,D0                   ;Back up to D0
00001F30  0240 0F00               1405              ANDI        #$0F00,D0               ;We only need the second byte (size)
00001F34  E088                    1406              LSR.L       #8,D0                   ;Shift to Right-most position
00001F36  0C40 0008               1407              CMPI        #8,D0                   ;Compare to see if it is a LONG
00001F3A  6700 000E               1408              BEQ         add_long_buf            ;Store .L to buffer
00001F3E  0C40 0000               1409              CMPI        #0,D0                   ;Compare to see if it is a WORD
00001F42  6700 0010               1410              BEQ         add_word_buf            ;Store .W to buffer
00001F46  1C3C 0001               1411              MOVE.B      #1,D6                   ;Enable bad flag bit for all other sizes
00001F4A                          1412  
00001F4A                          1413  *Helper Routine to add Data Types to buffer
00001F4A                          1414  add_long_buf
00001F4A  3CFC 2184               1415              MOVE.W      #LONG_EXT,(A6)+         ;Add to buffer
00001F4E                          1416  
00001F4E                          1417              *Get Close Parentheses Sign
00001F4E  3CFC 216A               1418              MOVE.W      #CLOSE_PAREN,(A6)+      ;Load close Paren to buffer
00001F52  4E75                    1419              RTS                                 ;Return
00001F54                          1420  
00001F54                          1421  add_word_buf
00001F54  3CF9 0000217E           1422              MOVE.W      WORD_EXT,(A6)+          ;Add to buffer
00001F5A                          1423  
00001F5A                          1424              *Get Close Parentheses Sign
00001F5A  3CFC 216A               1425              MOVE.W      #CLOSE_PAREN,(A6)+      ;Load close Paren to buffer
00001F5E  4E75                    1426              RTS                                 ;Return
00001F60                          1427  
00001F60                          1428  ********************* PC, Immediate, or Absolute Addressing *******************
00001F60                          1429  eaindex110
00001F60  43F9 00001F88           1430              LEA         subindex_tbl,A1         ;Loads the Subindex Jump Table
00001F66  3002                    1431              MOVE        D2,D0                   ;Store EA original - 6 bits
00001F68  C0FC 0006               1432              MULU        #6,D0                   ;Loads the offset for Jump Table
00001F6C  4EB1 0000               1433              JSR         00(A1,D0)               ;To SubIndex Jump Table
00001F70  4E75                    1434              RTS                                 ;Return when done
00001F72                          1435  
00001F72                          1436  ********************* PC, Immediate, or Absolute Addressing *******************
00001F72                          1437  eaindex111
00001F72  43F9 00001F88           1438              LEA         subindex_tbl,A1         ;Loads the Subindex Jump Table
00001F78  3002                    1439              MOVE        D2,D0                   ;Store EA original - 6 bits
00001F7A  0240 0007               1440              ANDI        #7,D0                   ;Get the Register bits
00001F7E  C0FC 0006               1441              MULU        #6,D0
00001F82  4EB1 0000               1442              JSR         00(A1,D0)               ;To SubIndex Jump Table
00001F86  4E75                    1443              RTS                                 ;Just Return
00001F88                          1444  
00001F88                          1445  ************************* aeindex110 Subindex Jump Table **********************
00001F88                          1446  subindex_tbl ;Uses Bitmask to differentiate Types
00001F88  4EF9 00001FB8           1447              JMP         easub000                ;Absolute Addressing - Word
00001F8E  4EF9 00001FE0           1448              JMP         easub001                ;Absolute Addressing - Long
00001F94  4EF9 00002022           1449              JMP         easub010                ;Indirect Program Counter w/ Displacement
00001F9A  4EF9 000020B8           1450              JMP         easub011                ;Unused
00001FA0  4EF9 0000205E           1451              JMP         easub100                ;Immediate Data
00001FA6  4EF9 000020BA           1452              JMP         easub101                ;Unused
00001FAC  4EF9 000020BC           1453              JMP         easub110                ;Unused
00001FB2  4EF9 000020BE           1454              JMP         easub111                ;Unused
00001FB8                          1455  
00001FB8                          1456  ************************** Absolute Addressing - Word *************************
00001FB8                          1457  easub000
00001FB8  48E7 9850               1458              MOVEM.L     A1/A3/D0/D3/D4,-(SP)
00001FBC                          1459              *Get Dollar Sign
00001FBC  3CFC 2176               1460              MOVE.W      #DOLLAR_SIGN,(A6)+                ;Add to buffer
00001FC0                          1461  
00001FC0                          1462              *Prep for Conversion - Word
00001FC0  47F8 1468               1463              LEA         ascii_w,A3              ;Load variable for ascii storage
00001FC4  381C                    1464              MOVE.W      (A4)+,D4                ;Clear Word from pointer stack
00001FC6  301C                    1465              MOVE.W      (A4)+,D0                ;Get the WORD data
00001FC8  3600                    1466              MOVE.W      D0,D3                   ;Back up to D3
00001FCA  4284                    1467              CLR.L       D4                      ;Empty Data Register
00001FCC  183C 0004               1468              MOVE.B      #4,D4              ;Get the length of Hex value - WORD
00001FD0  6100 F29E               1469              BSR         conv_to_ascii           ;Branch to convert to ASCII
00001FD4                          1470  
00001FD4  43F8 1468               1471              LEA         ascii_w,A1
00001FD8  2CC9                    1472              MOVE.L      A1,(A6)+                ;Add to buffer
00001FDA                          1473  
00001FDA  4CDF 0A19               1474              MOVEM.L     (SP)+,A1/A3/D0/D3/D4
00001FDE  4E75                    1475              RTS                                 ;Return
00001FE0                          1476  
00001FE0                          1477  ************************** Absolute Addressing - Long *************************
00001FE0                          1478  easub001
00001FE0  48E7 9850               1479              MOVEM.L     A1/A3/D0/D3/D4,-(SP)
00001FE4                          1480  
00001FE4                          1481              *Get Dollar Sign
00001FE4  3CFC 2176               1482              MOVE.W      #DOLLAR_SIGN,(A6)+                ;Add to buffer
00001FE8                          1483  
00001FE8                          1484              *Prep for Conversion - LONG
00001FE8  47F8 1468               1485              LEA         ascii_w,A3          ;Load variable for ascii storage
00001FEC  301C                    1486              MOVE.W      (A4)+,D0                ;Get the LONG data
00001FEE  B07C 0000               1487              CMP.W       #0,D0
00001FF2  6700 0014               1488              BEQ         SKIP
00001FF6                          1489  
00001FF6  3600                    1490              MOVE.W      D0,D3                   ;Back up to D3
00001FF8  4284                    1491              CLR.L       D4                      ;Empty Data Register
00001FFA  183C 0004               1492              MOVE.B      #4,D4               ;Get the length of Hex value - LONG
00001FFE  6100 F270               1493              BSR         conv_to_ascii           ;Branch to convert to ASCII
00002002                          1494  
00002002                          1495              *Store Hex Address to Buffer
00002002  43F8 1468               1496              LEA         ascii_w,A1
00002006  3CC9                    1497              MOVE.W      A1,(A6)+                ;Add to buffer
00002008                          1498  SKIP
00002008  301C                    1499              MOVE.W      (A4)+,D0                ;Get the LONG data
0000200A  3600                    1500              MOVE.W      D0,D3                   ;Back up to D3
0000200C  4284                    1501              CLR.L       D4                      ;Empty Data Register
0000200E  183C 0004               1502              MOVE.B      #4,D4               ;Get the length of Hex value - LONG
00002012  6100 F25C               1503              BSR         conv_to_ascii           ;Branch to convert to ASCII
00002016                          1504  
00002016                          1505  
00002016                          1506              *Store Hex Address to Buffer
00002016  43F8 1468               1507              LEA         ascii_w,A1
0000201A  3CC9                    1508              MOVE.W      A1,(A6)+                ;Add to buffer
0000201C                          1509  
0000201C  4CDF 0A19               1510              MOVEM.L     (SP)+,A1/A3/D0/D3/D4
00002020  4E75                    1511              RTS                                 ;Return
00002022                          1512  
00002022                          1513  ******************* Program Counter Indirect w/ Displacement ******************
00002022                          1514  easub010
00002022  48E7 9850               1515              MOVEM.L     A1/A3/D0/D3/D4,-(SP)                ;Save D4 Register
00002026  47F8 1468               1516              LEA         ascii_w,A3              ;Get converted address word
0000202A                          1517  
0000202A                          1518              *Get Dollar Sign
0000202A  3CFC 2176               1519              MOVE.W      #DOLLAR_SIGN,(A6)+      ;Add to buffer
0000202E                          1520  
0000202E                          1521              *Get the Displacement from Extension Word
0000202E  5404                    1522              ADDI.B      #2,D4                   ;Increment Address Location
00002030  3015                    1523              MOVE.W      (A5),D0                 ;Get word data from Extension Word
00002032  0680 FFFF0000           1524              ADDI.L      #$FFFF0000,D0           ;Pad to cover Sign
00002038  D084                    1525              ADD.L       D4,D0                   ;Now add to get Displacement
0000203A                          1526  
0000203A                          1527              *Convert Displacement to Ascii - WORD
0000203A  2600                    1528              MOVE.L      D0,D3                   ;Put Hex Value in D3
0000203C  4284                    1529              CLR.L       D4                      ;Empty Data Register
0000203E  183C 0004               1530              MOVE.B      #$4,D4                  ;Get the length of Hex Value - WORD
00002042  6100 F22C               1531              BSR         conv_to_ascii           ;Convert to ASCII
00002046                          1532  
00002046                          1533              *Store Hex Address to Buffer
00002046  224B                    1534              MOVEA.L     A3,A1                   ;Move ASCII value to A1
00002048  3CC9                    1535              MOVE.W      A1,(A6)+                ;Load into buffer
0000204A  267C 00000000           1536              MOVEA.L     #$00000000,A3           ;Reset contents of A3
00002050                          1537  
00002050                          1538              *Add Program Counter to Buffer
00002050  43F9 0000218A           1539              LEA         prog_ctr,A1             ;ASCII value for (PC)
00002056  3CC9                    1540              MOVE.W      A1,(A6)+                ;Load into buffer
00002058                          1541  
00002058  4CDF 0A19               1542              MOVEM.L     (SP)+,A1/A3/D0/D3/D4
0000205C  4E75                    1543              RTS                                 ;Return
0000205E                          1544  
0000205E                          1545  ************************ Immediate Addressing w/ Data *************************
0000205E                          1546  easub100
0000205E  48E7 9850               1547              MOVEM.L     A1/A3/D0/D3/D4,-(SP)
00002062                          1548  
00002062  47F8 147C               1549              LEA         ASCII_IMMEDIATE,A3      ;Get converted Address Word
00002066  0C45 0002               1550              CMPI        #2,D5                   ;Check length
0000206A  6700 000A               1551              BEQ         easub100_l              ;Branch to Long Subroutine
0000206E  0C45 0003               1552              CMPI        #3,D5                   ;Check for invalid Length
00002072  6700 003E               1553              BEQ         easub100_badLen         ;Branch to Bad Length Flag Subroutine
00002076                          1554  
00002076                          1555  easub100_l
00002076                          1556              *Get Pound Sign
00002076  3CFC 2196               1557              MOVE.W      #POUND_SIGN,(A6)+
0000207A                          1558  
0000207A                          1559              *Get Dollar Sign
0000207A  3CFC 2176               1560              MOVE.W      #DOLLAR_SIGN,(A6)+
0000207E                          1561  
0000207E  4284                    1562              CLR.L       D4                      ;Empty Data Register
00002080  BE3C 0002               1563              CMP.B       #2,D7
00002084  6700 0006               1564              BEQ         LONG
00002088  6000 000C               1565              BRA         WORD
0000208C                          1566  
0000208C                          1567  LONG
0000208C  183C 0008               1568              MOVE.B      #8,D4               ;Get the length of Hex value - LONG
00002090  201C                    1569              MOVE.L      (A4)+,D0            ;Get the LONG data
00002092  6000 000E               1570              BRA         NEXT
00002096                          1571  WORD
00002096  183C 0004               1572              MOVE.B      #4,D4               ;Get the length of Hex value - WORD
0000209A  301C                    1573              MOVE.W      (A4)+,D0            ;Get the WORD data
0000209C  6600 0004               1574              BNE         NEXT                ;Branch if not zeros
000020A0  301C                    1575              MOVE.W      (A4)+,D0            ;Get the WORD data
000020A2                          1576  NEXT
000020A2  2600                    1577              MOVE.L      D0,D3               ;Back up to D3
000020A4  6100 F1CA               1578              BSR         conv_to_ascii       ;Branch to convert to ASCII
000020A8                          1579  
000020A8                          1580              *Store Hex Address to Buffer
000020A8  3CFC 147C               1581              MOVE.W      #ASCII_IMMEDIATE,(A6)+  ;Add to buffer
000020AC                          1582  
000020AC  4CDF 0A19               1583              MOVEM.L     (SP)+,A1/A3/D0/D3/D4
000020B0                          1584  
000020B0  4E75                    1585              RTS                                 ;Return
000020B2                          1586  
000020B2                          1587  easub100_badLen
000020B2  1C3C 0001               1588              MOVE.B      #1,D6                   ;Enable Bad Flag bit
000020B6  4E75                    1589              RTS                                 ;Return
000020B8                          1590  
000020B8  4E75                    1591  easub011    RTS
000020BA  4E75                    1592  easub101    RTS
000020BC  4E75                    1593  easub110    RTS
000020BE  4E75                    1594  easub111    RTS
000020C0                          1595  *******************************************************************************
000020C0                          1596  *EAR_movem - Sends the value of the list of registers found within the Register
000020C0                          1597  *            List Mask Field (RLMF) within the Extension word.
000020C0                          1598  *          - Will either predecrement or post-increment depending on the
000020C0                          1599  *            Direction Bit (Bit 10 equals 0 ->predecrement)
000020C0                          1600  *               ~Predecrement: Dn,An        ~Postincrement: An,Dn
000020C0                          1601  *******************************************************************************
000020C0                          1602  EAR_movem
000020C0  48E7 FC40               1603              MOVEM.L      D0-D5/A1,-(SP)         ;Save the Registers to the Stack
000020C4  2800                    1604              MOVE.L      D0,D4                   ;Back up the Direction Bit
000020C6  321D                    1605              MOVE.W      (A5)+,D1                ;Get the RLMF
000020C8  2A01                    1606              MOVE.L      D1,D5                   ;Back up the RLMF
000020CA  4282                    1607              CLR.L       D2                      ;Empty Data Register
000020CC  4283                    1608              CLR.L       D3                      ;Empty Data Register
000020CE  0C40 0000               1609              CMPI        #0,D0                   ;Check for Predecrement
000020D2  6700 0050               1610              BEQ         predec_loop             ;Branch to Predecrement subroutine
000020D6  143C 000F               1611              MOVE.B      #15,D2                  ;RLMF counter starts at 15 for Postincrement
000020DA  0C40 0001               1612              CMPI        #1,D0                   ;Check for Postincrement
000020DE  6700 0008               1613              BEQ         post_loop              ;Branch to Postincrement subroutine
000020E2  1C3C 0001               1614              MOVE.B      #1,D6                   ;Enable Bad Flag bit
000020E6  4E75                    1615              RTS                                 ;Return
000020E8                          1616  
000020E8                          1617  ************************** Postincrement Subroutine ***************************
000020E8                          1618  post_loop
000020E8  0501                    1619              BTST        D2,D1                   ;Get current bit of RLMF
000020EA  6700 001E               1620              BEQ         post_incr               ;Branch if inactive
000020EE  1003                    1621              MOVE.B      D3,D0                   ;Prep to write Register to Buffer
000020F0  0C42 0008               1622              CMPI        #8,D2                   ;Check to see if 8-bits or less
000020F4  6D00 000A               1623              BLT         post_data               ;If less, it's a Data Register - Branch
000020F8  6100 F1C6               1624              BSR         send_addr_buf           ;If not, send the address register to buffer
000020FC  6000 0006               1625              BRA         post_skip               ;Skip to adding slash
00002100                          1626  post_data
00002100  6100 F1DC               1627              BSR         send_data_buf           ;Send data register to buffer
00002104                          1628  
00002104                          1629  post_skip   *Get Forward Slash
00002104  3CFC 2192               1630              MOVE.W      #F_SLASH,(A6)+          ;Move forward slash to buffer
00002108  2205                    1631              MOVE.L      D5,D1                   ;Get original RLMF
0000210A                          1632  
0000210A                          1633  post_incr
0000210A  5302                    1634              SUBI.B      #1,D2                   ;Decrement the RLMF Counter
0000210C  0C02 0000               1635              CMPI.B      #0,D2                   ;Range check for RLMF Counter (<16)
00002110  6700 004E               1636              BEQ         movem_exit              ;Exit if full
00002114  5203                    1637              ADDI.B      #1,D3                   ;Increment Output Register Counter
00002116  0C03 0008               1638              CMPI.B      #8,D3                   ;Range check for Output Register
0000211A  6700 0004               1639              BEQ         post_clr                ;Branch to clear register, then loop
0000211E  60C8                    1640              BRA         post_loop               ;Branch to loop without clearing
00002120                          1641  
00002120                          1642  post_clr
00002120  4243                    1643              CLR.W       D3                      ;Clear the Output Register Counter
00002122  60C4                    1644              BRA         post_loop               ;Loop again
00002124                          1645  
00002124                          1646  
00002124                          1647  *************************** Predecrement Subroutine ***************************
00002124                          1648  predec_loop
00002124  0501                    1649              BTST        D2,D1                   ;Get current bit of RLMF
00002126  6700 001E               1650              BEQ         predec_incr             ;Branch if inactive
0000212A  1003                    1651              MOVE.B      D3,D0                   ;Prepare to write to Buffer
0000212C  0C42 0008               1652              CMPI        #8,D2                   ;Check to see if 8-bits or less
00002130  6D00 000A               1653              BLT         predec_data             ;If less, it's a Data Register - Branch
00002134  6100 F18A               1654              BSR         send_addr_buf           ;If not, send the address register to buffer
00002138  6000 0006               1655              BRA         predec_skip             ;Skip to adding slash
0000213C                          1656  predec_data
0000213C  6100 F1A0               1657              BSR         send_data_buf           ;Send data register to buffer
00002140                          1658  
00002140                          1659  predec_skip
00002140                          1660              *Get Forward Slash
00002140  3CFC 2192               1661              MOVE.W      #F_SLASH,(A6)+          ;Move forward slash to buffer
00002144  2205                    1662              MOVE.L      D5,D1                   ;Get original RLMF
00002146                          1663  
00002146                          1664  predec_incr
00002146  5202                    1665              ADDI.B      #1,D2                   ;Increment the RLMF Counter
00002148  0C02 0010               1666              CMPI.B      #16,D2                  ;Range check for RLMF Counter (<16)
0000214C  6700 0012               1667              BEQ         movem_exit              ;Exit if full
00002150  5203                    1668              ADDI.B      #1,D3                   ;Increment Output Register Counter
00002152  0C03 0008               1669              CMPI.B      #8,D3                   ;Range check for Output Register
00002156  6700 0004               1670              BEQ         predec_clr              ;Branch to clear register, then loop
0000215A  60C8                    1671              BRA         predec_loop             ;Branch to loop without clearing
0000215C                          1672  
0000215C                          1673  predec_clr
0000215C  4243                    1674              CLR.W       D3                      ;Clear the Output Register Counter
0000215E  60C4                    1675              BRA         predec_loop             ;Loop again
00002160                          1676  
00002160                          1677  movem_exit
00002160  4CDF 020B               1678              MOVEM.L     (SP)+,D0/D1/D3/A1       ;Restore Registers
00002164  4E75                    1679              RTS
00002166                          1680  *******************************************************************************
00002166                          1681  *                                 EA Library
00002166                          1682  *******************************************************************************
00002166= 28 00                   1683  open_paren      DC.B    '(',0       ;Open Parentheses
00002168= 0001                    1684  open_parenLen   DC.W    1           ;Length of Open Parentheses
0000216A= 29 00                   1685  close_paren     DC.B    ')',0       ;Close Parentheses
0000216C= 0001                    1686  close_parenLen  DC.W    1           ;Length of Close Parenthese
0000216E= 2B 00                   1687  plus_sign       DC.B    '+',0       ;Increment
00002170= 0001                    1688  plus_signLen    DC.W    1           ;Length of Increment
00002172= 2D 00                   1689  minus_sign      DC.B    '-',0       ;Decrement
00002174= 0001                    1690  minus_signLen   DC.W    1           ;Length of Decrement
00002176= 24 00                   1691  dollar_sign     DC.B    '$',0       ;Dollar Sign
00002178= 0001                    1692  dollar_signLen  DC.W    1           ;Length of Dollar Sign
0000217A= 2C 00                   1693  comma_sign      DC.B    ',',0       ;Comma
0000217C= 0001                    1694  comma_signLen   DC.W    1           ;Length of the Comma
0000217E= 2E 57 00                1695  word_ext        DC.B    '.W',0      ;Word Extension Indicator
00002182= 0002                    1696  word_extLen     DC.W    2           ;Length of Word Extension
00002184= 2E 4C 00                1697  long_ext        DC.B    '.L',0      ;Long Extension Indicator
00002188= 0002                    1698  long_extLen     DC.W    2           ;Length of Long Extension
0000218A= 28 50 43 29 00          1699  prog_ctr        DC.B    '(PC)',0    ;Program Counter
00002190= 0004                    1700  prog_ctrLen     DC.W    4           ;Length of Program Couner
00002192= 2F 00                   1701  f_slash         DC.B    '/',0       ;Forward Slash
00002194= 0001                    1702  f_slashLen      DC.W    1           ;Length of Forward Slash
00002196= 23 00                   1703  pound_sign      DC.B    '#',0       ;Pound symbol for immediate data
00002198= 0001                    1704  pound_signLen   DC.W    1           ;Length of pound
0000219A= 2020 2020 0000          1705  tab_sign        DC.W    '    ',0
000021A0= 04                      1706  tab_Len         DC.B    4
000021A1                          1707  
000021A2                          1708  asc_wrd         DS.W    1           ;Word converted to ASCII
000021A4                          1709  *******************************************************************************
000021A4                          1710  *                               End EA Routine
000021A4                          1711  *******************************************************************************
000021A4                          1712  
000021A4                          1713  
000021A4                          1714  
000021A4                          1715  
000021A4                          1716  
000021A4                          1717  *******************************************************************************
000021A4                          1718  */////////////////////////////////////////////////////////////////////////////*
000021A4                          1719  *       Testing Routines for Disassembler live below here                     *
000021A4                          1720  *\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*
000021A4                          1721  *******************************************************************************
000021A4                          1722  
000021A4                          1723  
000021A4                          1724  *******************************************************************************
000021A4                          1725  *                         Test Disassemble Routines
000021A4                          1726  *******************************************************************************
000021A4                          1727  * instructions could contain as many as 5 16-bit words
000021A4                          1728  * e.g. MOVE.L   $AAAAAAAA,$55555555
000021A4                          1729  
00007000                          1730                  ORG         $7000
00007000                          1731  
00007000                          1732  *******************************************************************************
00007000                          1733  *   NOP                                 ; Unsized
00007000                          1734  *******************************************************************************
00007000                          1735  
00007000  4E71                    1736      NOP                                 ; first instruction to disassemble
00007002                          1737  
00007002                          1738  *******************************************************************************
00007002                          1739  *   NEG         <ea>                    ; Size = (Byte, Word, Long)
00007002                          1740  *******************************************************************************
00007002                          1741  
00007002                          1742      *BYTE*                              **<ea>**
00007002  4400                    1743      NEG.B       D0                      ; Data Register Direct
00007004  4410                    1744      NEG.B       (A0)                    ; Addr Reg Indirect
00007006  4418                    1745      NEG.B       (A0)+                   ; Addr Reg Indirect with Post increment
00007008  4420                    1746      NEG.B       -(A0)                   ; Addr Reg Indirect with Pre decrement
0000700A  4439 0000AAAA           1747      NEG.B       $AAAA                  ; Absolute Word Address
00007010  4439 AAAAAAAA           1748      NEG.B       $AAAAAAAA              ; Absolute Long Address
00007016                          1749  
00007016                          1750      *WORD*
00007016  4440                    1751      NEG.W       D0                      ; Data Register Direct
00007018  4450                    1752      NEG.W       (A0)                    ; Addr Reg Indirect
0000701A  4458                    1753      NEG.W       (A0)+                   ; Addr Reg Indirect with Post increment
0000701C  4460                    1754      NEG.W       -(A0)                   ; Addr Reg Indirect with Pre decrement
0000701E  4479 0000AAAA           1755      NEG.W       $AAAA                  ; Absolute Word Address
00007024  4479 AAAAAAAA           1756      NEG.W       $AAAAAAAA              ; Absolute Long Address
0000702A                          1757  
0000702A                          1758      *LONG*
0000702A  4480                    1759      NEG.L       D0                      ; Data Register Direct
0000702C  4490                    1760      NEG.L       (A0)                    ; Addr Reg Indirect
0000702E  4498                    1761      NEG.L       (A0)+                   ; Addr Reg Indirect with Post increment
00007030  44A0                    1762      NEG.L       -(A0)                   ; Addr Reg Indirect with Pre decrement
00007032  44B9 0000AAAA           1763      NEG.L       $AAAA                  ; Absolute Word Address
00007038  44B9 AAAAAAAA           1764      NEG.L       $AAAAAAAA              ; Absolute Long Address
0000703E                          1765  
0000703E                          1766  *******************************************************************************
0000703E                          1767  *   JMP         <ea>                    ; Unsized
0000703E                          1768  *******************************************************************************
0000703E                          1769  
0000703E  4ED0                    1770      JMP         (A0)                    ; Addr Reg Indirect
00007040  4EF9 0000AAAA           1771      JMP         $AAAA                   ; Absolute Word Address
00007046  4EF9 AAAAAAAA           1772      JMP         $AAAAAAAA               ; Absolute Long Address
0000704C                          1773  
0000704C                          1774  *******************************************************************************
0000704C                          1775  *   JSR         <ea>                    ; Unsized
0000704C                          1776  *******************************************************************************
0000704C                          1777  
0000704C  4E90                    1778      JSR         (A0)                    ; Addr Reg Indirect
0000704E  4EB9 0000AAAA           1779      JSR         $AAAA                   ; Absolute Word Address
00007054  4EB9 AAAAAAAA           1780      JSR         $AAAAAAAA               ; Absolute Long Address
0000705A                          1781  
0000705A                          1782  *******************************************************************************
0000705A                          1783  *   RTS                                 ; Unsized
0000705A                          1784  *******************************************************************************
0000705A                          1785  
0000705A  4E75                    1786      RTS
0000705C                          1787  
0000705C                          1788  *******************************************************************************
0000705C                          1789  *   MOVE        <ea>,<ea>               ; Size = (Byte, Word, Long)
0000705C                          1790  *******************************************************************************
0000705C                          1791  
0000705C                          1792      *BYTE*                              **DESTINATION <ea>**
0000705C  1200                    1793      MOVE.B      D0,D1                   ; Data Register Direct
0000705E  1280                    1794      MOVE.B      D0,(A1)                 ; Addr Reg Indirect
00007060  12C0                    1795      MOVE.B      D0,(A1)+                ; Addr Reg Indirect with Post increment
00007062  1300                    1796      MOVE.B      D0,-(A1)                ; Addr Reg Indirect with Pre decrement
00007064  13C0 0000AAAA           1797      MOVE.B      D0,$AAAA                ; Absolute Word Address
0000706A  13C0 AAAAAAAA           1798      MOVE.B      D0,$AAAAAAAA            ; Absolute Long Address
00007070                          1799  
00007070                          1800      *WORD*
00007070  3200                    1801      MOVE.W      D0,D1                   ; Data Register Direct
00007072  3280                    1802      MOVE.W      D0,(A1)                 ; Addr Reg Indirect
00007074  32C0                    1803      MOVE.W      D0,(A1)+                ; Addr Reg Indirect with Post increment
00007076  3300                    1804      MOVE.W      D0,-(A1)                ; Addr Reg Indirect with Pre decrement
00007078  33C0 0000AAAA           1805      MOVE.W      D0,$AAAA                ; Absolute Word Address
0000707E  33C0 AAAAAAAA           1806      MOVE.W      D0,$AAAAAAAA            ; Absolute Long Address
00007084                          1807  
00007084                          1808      *LONG*
00007084  2200                    1809      MOVE.L      D0,D1                   ; Data Register Direct
00007086  2280                    1810      MOVE.L      D0,(A1)                 ; Addr Reg Indirect
00007088  22C0                    1811      MOVE.L      D0,(A1)+                ; Addr Reg Indirect with Post increment
0000708A  2300                    1812      MOVE.L      D0,-(A1)                ; Addr Reg Indirect with Pre decrement
0000708C  23C0 0000AAAA           1813      MOVE.L      D0,$AAAA                ; Absolute Word Address
00007092  23C0 AAAAAAAA           1814      MOVE.L      D0,$AAAAAAAA            ; Absolute Long Address
00007098                          1815  
00007098                          1816      *BYTE*                              **SOURCE <ea>**
00007098  1200                    1817      MOVE.B      D0,D1                   ; Data Register Direct
0000709A  1210                    1818      MOVE.B      (A0),D1                 ; Addr Reg Indirect
0000709C  1218                    1819      MOVE.B      (A0)+,D1                ; Addr Reg Indirect with Post increment
0000709E  1220                    1820      MOVE.B      -(A0),D1                ; Addr Reg Indirect with Pre decrement
000070A0  1039 0000AAAA           1821      MOVE.B      $AAAA,D0                ; Absolute Word Address
000070A6  1039 AAAAAAAA           1822      MOVE.B      $AAAAAAAA,D0            ; Absolute Long Address
000070AC  123C 00DD               1823      MOVE.B      #$DD,D1                 ; Immediate Data
000070B0                          1824  
000070B0                          1825      *WORD*
000070B0  3200                    1826      MOVE.W      D0,D1                   ; Data Register Direct
000070B2  3208                    1827      MOVE.W      A0,D1                   ; Addr Reg Direct
000070B4  3210                    1828      MOVE.W      (A0),D1                 ; Addr Reg Indirect
000070B6  3218                    1829      MOVE.W      (A0)+,D1                ; Addr Reg Indirect with Post increment
000070B8  3220                    1830      MOVE.W      -(A0),D1                ; Addr Reg Indirect with Pre decrement
000070BA  3039 0000AAAA           1831      MOVE.W      $AAAA,D0                ; Absolute Word Address
000070C0  3039 AAAAAAAA           1832      MOVE.W      $AAAAAAAA,D0            ; Absolute Long Address
000070C6  323C DDDD               1833      MOVE.W      #$DDDD,D1               ; Immediate Data
000070CA                          1834  
000070CA                          1835      *LONG*
000070CA  2200                    1836      MOVE.L      D0,D1                   ; Data Register Direct
000070CC  2208                    1837      MOVE.L      A0,D1                   ; Addr Reg Direct
000070CE  2210                    1838      MOVE.L      (A0),D1                 ; Addr Reg Indirect
000070D0  2218                    1839      MOVE.L      (A0)+,D1                ; Addr Reg Indirect with Post increment
000070D2  2220                    1840      MOVE.L      -(A0),D1                ; Addr Reg Indirect with Pre decrement
000070D4  2039 0000AAAA           1841      MOVE.L      $AAAA,D0                ; Absolute Word Address
000070DA  2039 AAAAAAAA           1842      MOVE.L      $AAAAAAAA,D0            ; Absolute Long Address
000070E0  223C DDDDDDDD           1843      MOVE.L      #$DDDDDDDD,D1           ; Immediate Data
000070E6                          1844  
000070E6                          1845  *******************************************************************************
000070E6                          1846  *   MOVEA       <ea>,An                 ; Size = (Word, Long)
000070E6                          1847  *******************************************************************************
000070E6                          1848  
000070E6                          1849      *WORD*                              **SOURCE <ea>**
000070E6  3240                    1850      MOVEA.W     D0,A1                   ; Data Register Direct
000070E8  3248                    1851      MOVEA.W     A0,A1                   ; Addr Reg Direct
000070EA  3250                    1852      MOVEA.W     (A0),A1                 ; Addr Reg Indirect
000070EC  3258                    1853      MOVEA.W     (A0)+,A1                ; Addr Reg Indirect with Post increment
000070EE  3260                    1854      MOVEA.W     -(A0),A1                ; Addr Reg Indirect with Pre decrement
000070F0  3279 0000AAAA           1855      MOVEA.W     $AAAA,A1                ; Absolute Word Address
000070F6  3279 AAAAAAAA           1856      MOVEA.W     $AAAAAAAA,A1            ; Absolute Long Address
000070FC  327C DDDD               1857      MOVEA.W     #$DDDD,A1               ; Immediate Data
00007100                          1858  
00007100                          1859      *LONG*
00007100  2240                    1860      MOVEA.L     D0,A1                   ; Data Register Direct
00007102  2248                    1861      MOVEA.L     A0,A1                   ; Addr Reg Direct
00007104  2250                    1862      MOVEA.L     (A0),A1                 ; Addr Reg Indirect
00007106  2258                    1863      MOVEA.L     (A0)+,A1                ; Addr Reg Indirect with Post increment
00007108  2260                    1864      MOVEA.L     -(A0),A1                ; Addr Reg Indirect with Pre decrement
0000710A  2279 0000AAAA           1865      MOVEA.L     $AAAA,A1                ; Absolute Word Address
00007110  2279 AAAAAAAA           1866      MOVEA.L     $AAAAAAAA,A1            ; Absolute Long Address
00007116  227C DDDDDDDD           1867      MOVEA.L     #$DDDDDDDD,A1           ; Immediate Data
0000711C                          1868  
0000711C                          1869  *******************************************************************************
0000711C                          1870  *   ADDA        <ea>,An                 ; Size = (Word, Long)
0000711C                          1871  *******************************************************************************
0000711C                          1872  
0000711C                          1873      *WORD*                              **SOURCE <ea>**
0000711C  D2C0                    1874      ADDA.W      D0,A1                   ; Data Register Direct
0000711E  D2C8                    1875      ADDA.W      A0,A1                   ; Addr Reg Direct
00007120  D2D0                    1876      ADDA.W      (A0),A1                 ; Addr Reg Indirect
00007122  D2D8                    1877      ADDA.W      (A0)+,A1                ; Addr Reg Indirect with Post increment
00007124  D2E0                    1878      ADDA.W      -(A0),A1                ; Addr Reg Indirect with Pre decrement
00007126  D2F9 0000AAAA           1879      ADDA.W      $AAAA,A1                ; Absolute Word Address
0000712C  D2F9 AAAAAAAA           1880      ADDA.W      $AAAAAAAA,A1            ; Absolute Long Address
00007132  D2FC DDDD               1881      ADDA.W      #$DDDD,A1               ; Immediate Data
00007136                          1882  
00007136                          1883      *LONG*
00007136  D3C0                    1884      ADDA.L      D0,A1                   ; Data Register Direct
00007138  D3C8                    1885      ADDA.L      A0,A1                   ; Addr Reg Direct
0000713A  D3D0                    1886      ADDA.L      (A0),A1                 ; Addr Reg Indirect
0000713C  D3D8                    1887      ADDA.L      (A0)+,A1                ; Addr Reg Indirect with Post increment
0000713E  D3E0                    1888      ADDA.L      -(A0),A1                ; Addr Reg Indirect with Pre decrement
00007140  D3F9 0000AAAA           1889      ADDA.L      $AAAA,A1                ; Absolute Word Address
00007146  D3F9 AAAAAAAA           1890      ADDA.L      $AAAAAAAA,A1            ; Absolute Long Address
0000714C  D3FC 0000DDDD           1891      ADDA.L      #$DDDD,A1               ; Immediate Data
00007152                          1892  
00007152                          1893  *******************************************************************************
00007152                          1894  *   ADDI        #<data>,<ea>            ; Size = (Byte, Word, Long)
00007152                          1895  *******************************************************************************
00007152                          1896  
00007152                          1897      *BYTE*                              **DESTINATION <ea>**
00007152  0601 00DD               1898      ADDI.B      #$DD,D1                 ; Data Register Direct
00007156  0611 00DD               1899      ADDI.B      #$DD,(A1)               ; Addr Reg Indirect
0000715A  0619 00DD               1900      ADDI.B      #$DD,(A1)+              ; Addr Reg Indirect with Post increment
0000715E  0621 00DD               1901      ADDI.B      #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
00007162  0639 00DD 0000AAAA      1902      ADDI.B      #$DD,$AAAA              ; Absolute Word Address
0000716A  0639 00DD AAAAAAAA      1903      ADDI.B      #$DD,$AAAAAAAA          ; Absolute Long Address
00007172                          1904  
00007172                          1905      *WORD*
00007172  0641 DDDD               1906      ADDI.W      #$DDDD,D1               ; Data Register Direct
00007176  0651 DDDD               1907      ADDI.W      #$DDDD,(A1)             ; Addr Reg Indirect
0000717A  0659 DDDD               1908      ADDI.W      #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
0000717E  0661 DDDD               1909      ADDI.W      #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
00007182  0679 DDDD 0000AAAA      1910      ADDI.W      #$DDDD,$AAAA            ; Absolute Word Address
0000718A  0679 DDDD AAAAAAAA      1911      ADDI.W      #$DDDD,$AAAAAAAA        ; Absolute Long Address
00007192                          1912  
00007192                          1913      *LONG*
00007192  0681 DDDDDDDD           1914      ADDI.L      #$DDDDDDDD,D1           ; Data Register Direct
00007198  0691 DDDDDDDD           1915      ADDI.L      #$DDDDDDDD,(A1)         ; Addr Reg Indirect
0000719E  0699 DDDDDDDD           1916      ADDI.L      #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
000071A4  06A1 DDDDDDDD           1917      ADDI.L      #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
000071AA  06B9 DDDDDDDD 0000AAAA  1918      ADDI.L      #$DDDDDDDD,$AAAA        ; Absolute Word Address
000071B4  06B9 DDDDDDDD AAAAAAAA  1919      ADDI.L      #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
000071BE                          1920  
000071BE                          1921  *******************************************************************************
000071BE                          1922  *   ADDQ        #<data>,<ea>            ; Size = (Byte, Word, Long)
000071BE                          1923  *******************************************************************************
000071BE                          1924  
000071BE                          1925      *BYTE*                              **DESTINATION <ea>**
000071BE  5001                    1926      ADDQ.B      #8,D1                   ; Data Register Direct
000071C0  5011                    1927      ADDQ.B      #8,(A1)                 ; Addr Reg Indirect
000071C2  5019                    1928      ADDQ.B      #8,(A1)+                ; Addr Reg Indirect with Post increment
000071C4  5021                    1929      ADDQ.B      #8,-(A1)                ; Addr Reg Indirect with Pre decrement
000071C6  5039 0000AAAA           1930      ADDQ.B      #8,$AAAA                ; Absolute Word Address
000071CC  5039 AAAAAAAA           1931      ADDQ.B      #8,$AAAAAAAA            ; Absolute Long Address
000071D2                          1932  
000071D2                          1933      *WORD*
000071D2  5041                    1934      ADDQ.W      #8,D1                   ; Data Register Direct
000071D4  5049                    1935      ADDQ.W      #8,A1                   ; Addr Reg Direct
000071D6  5051                    1936      ADDQ.W      #8,(A1)                 ; Addr Reg Indirect
000071D8  5059                    1937      ADDQ.W      #8,(A1)+                ; Addr Reg Indirect with Post increment
000071DA  5061                    1938      ADDQ.W      #8,-(A1)                ; Addr Reg Indirect with Pre decrement
000071DC  5079 0000AAAA           1939      ADDQ.W      #8,$AAAA                ; Absolute Word Address
000071E2  5079 AAAAAAAA           1940      ADDQ.W      #8,$AAAAAAAA            ; Absolute Long Address
000071E8                          1941  
000071E8                          1942      *LONG*
000071E8  5081                    1943      ADDQ.L      #8,D1                   ; Data Register Direct
000071EA  5089                    1944      ADDQ.L      #8,A1                   ; Addr Reg Direct
000071EC  5091                    1945      ADDQ.L      #8,(A1)                 ; Addr Reg Indirect
000071EE  5099                    1946      ADDQ.L      #8,(A1)+                ; Addr Reg Indirect with Post increment
000071F0  50A1                    1947      ADDQ.L      #8,-(A1)                ; Addr Reg Indirect with Pre decrement
000071F2  50B9 0000AAAA           1948      ADDQ.L      #8,$AAAA                ; Absolute Word Address
000071F8  50B9 AAAAAAAA           1949      ADDQ.L      #8,$AAAAAAAA            ; Absolute Long Addres
000071FE                          1950  
000071FE                          1951  *******************************************************************************
000071FE                          1952  *   SUBA        <ea>,An                 ; Size = (Word, Long)
000071FE                          1953  *******************************************************************************
000071FE                          1954  
000071FE                          1955      *WORD*                              **SOURCE <ea>**
000071FE  92C0                    1956      SUBA.W      D0,A1                   ; Data Register Direct
00007200  92C8                    1957      SUBA.W      A0,A1                   ; Addr Reg Direct
00007202  92D0                    1958      SUBA.W      (A0),A1                 ; Addr Reg Indirect
00007204  92D8                    1959      SUBA.W      (A0)+,A1                ; Addr Reg Indirect with Post increment
00007206  92E0                    1960      SUBA.W      -(A0),A1                ; Addr Reg Indirect with Pre decrement
00007208  92F9 0000AAAA           1961      SUBA.W      $AAAA,A1                ; Absolute Word Address
0000720E  92F9 AAAAAAAA           1962      SUBA.W      $AAAAAAAA,A1            ; Absolute Long Address
00007214  92FC DDDD               1963      SUBA.W      #$DDDD,A1               ; Immediate Data
00007218                          1964  
00007218                          1965      *LONG*
00007218  93C0                    1966      SUBA.L      D0,A1                   ; Data Register Direct
0000721A  93C8                    1967      SUBA.L      A0,A1                   ; Addr Reg Direct
0000721C  93D0                    1968      SUBA.L      (A0),A1                 ; Addr Reg Indirect
0000721E  93D8                    1969      SUBA.L      (A0)+,A1                ; Addr Reg Indirect with Post increment
00007220  93E0                    1970      SUBA.L      -(A0),A1                ; Addr Reg Indirect with Pre decrement
00007222  93F9 0000AAAA           1971      SUBA.L      $AAAA,A1                ; Absolute Word Address
00007228  93F9 AAAAAAAA           1972      SUBA.L      $AAAAAAAA,A1            ; Absolute Long Address
0000722E  93FC DDDDDDDD           1973      SUBA.L      #$DDDDDDDD,A1           ; Immediate Data
00007234                          1974  
00007234                          1975  *******************************************************************************
00007234                          1976  *   SUBI        #<data>,<ea>            ; Size = (Byte, Word, Long)
00007234                          1977  *******************************************************************************
00007234                          1978  
00007234                          1979      *BYTE*                              **DESTINATION <ea>**
00007234  0401 00DD               1980      SUBI.B      #$DD,D1                 ; Data Register Direct
00007238  0411 00DD               1981      SUBI.B      #$DD,(A1)               ; Addr Reg Indirect
0000723C  0419 00DD               1982      SUBI.B      #$DD,(A1)+              ; Addr Reg Indirect with Post increment
00007240  0421 00DD               1983      SUBI.B      #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
00007244  0439 00DD 0000AAAA      1984      SUBI.B      #$DD,$AAAA              ; Absolute Word Address
0000724C  0439 00DD AAAAAAAA      1985      SUBI.B      #$DD,$AAAAAAAA          ; Absolute Long Address
00007254                          1986  
00007254                          1987      *WORD*
00007254  0441 DDDD               1988      SUBI.W      #$DDDD,D1               ; Data Register Direct
00007258  0451 DDDD               1989      SUBI.W      #$DDDD,(A1)             ; Addr Reg Indirect
0000725C  0459 DDDD               1990      SUBI.W      #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
00007260  0461 DDDD               1991      SUBI.W      #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
00007264  0479 DDDD 0000AAAA      1992      SUBI.W      #$DDDD,$AAAA            ; Absolute Word Address
0000726C  0479 DDDD AAAAAAAA      1993      SUBI.W      #$DDDD,$AAAAAAAA        ; Absolute Long Address
00007274                          1994  
00007274                          1995      *LONG*
00007274  0481 DDDDDDDD           1996      SUBI.L      #$DDDDDDDD,D1           ; Data Register Direct
0000727A  0491 DDDDDDDD           1997      SUBI.L      #$DDDDDDDD,(A1)         ; Addr Reg Indirect
00007280  0499 DDDDDDDD           1998      SUBI.L      #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
00007286  04A1 DDDDDDDD           1999      SUBI.L      #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
0000728C  04B9 DDDDDDDD 0000AAAA  2000      SUBI.L      #$DDDDDDDD,$AAAA        ; Absolute Word Address
00007296  04B9 DDDDDDDD AAAAAAAA  2001      SUBI.L      #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
000072A0                          2002  
000072A0                          2003  *******************************************************************************
000072A0                          2004  *   AND         <ea>,Dn                 ; Size = (Byte, Word, Long)
000072A0                          2005  *******************************************************************************
000072A0                          2006  
000072A0                          2007      *BYTE*                              **SOURCE <ea>**
000072A0  C200                    2008      AND.B       D0,D1                   ; Data Register Direct
000072A2  C210                    2009      AND.B       (A0),D1                 ; Addr Reg Indirect
000072A4  C218                    2010      AND.B       (A0)+,D1                ; Addr Reg Indirect with Post increment
000072A6  C220                    2011      AND.B       -(A0),D1                ; Addr Reg Indirect with Pre decrement
000072A8  C239 0000AAAA           2012      AND.B       $AAAA,D1                ; Absolute Word Address
000072AE  C239 AAAAAAAA           2013      AND.B       $AAAAAAAA,D1            ; Absolute Long Address
000072B4  C23C 00DD               2014      AND.B       #$DD,D1                 ; Immediate Data
000072B8                          2015  
000072B8                          2016      *WORD*
000072B8  C240                    2017      AND.W       D0,D1                   ; Data Register Direct
000072BA  C250                    2018      AND.W       (A0),D1                 ; Addr Reg Indirect
000072BC  C258                    2019      AND.W       (A0)+,D1                ; Addr Reg Indirect with Post increment
000072BE  C260                    2020      AND.W       -(A0),D1                ; Addr Reg Indirect with Pre decrement
000072C0  C279 0000AAAA           2021      AND.W       $AAAA,D1                ; Absolute Word Address
000072C6  C279 AAAAAAAA           2022      AND.W       $AAAAAAAA,D1            ; Absolute Long Address
000072CC  C27C 00DD               2023      AND.W       #$DD,D1                 ; Immediate Data
000072D0                          2024  
000072D0                          2025      *LONG*
000072D0  C280                    2026      AND.L       D0,D1                   ; Data Register Direct
000072D2  C290                    2027      AND.L       (A0),D1                 ; Addr Reg Indirect
000072D4  C298                    2028      AND.L       (A0)+,D1                ; Addr Reg Indirect with Post increment
000072D6  C2A0                    2029      AND.L       -(A0),D1                ; Addr Reg Indirect with Pre decrement
000072D8  C2B9 0000AAAA           2030      AND.L       $AAAA,D1                ; Absolute Word Address
000072DE  C2B9 AAAAAAAA           2031      AND.L       $AAAAAAAA,D1            ; Absolute Long Address
000072E4  C2BC 000000DD           2032      AND.L       #$DD,D1                 ; Immediate Data
000072EA                          2033  
000072EA                          2034  *******************************************************************************
000072EA                          2035  *   AND         Dn,<ea>                 ; Size = (Byte, Word, Long)
000072EA                          2036  *******************************************************************************
000072EA                          2037  
000072EA                          2038      *BYTE*                              **DESTINATION <ea>**
000072EA  C111                    2039      AND.B       D0,(A1)                 ; Addr Reg Indirect
000072EC  C119                    2040      AND.B       D0,(A1)+                ; Addr Reg Indirect with Post increment
000072EE  C121                    2041      AND.B       D0,-(A1)                ; Addr Reg Indirect with Pre decrement
000072F0  C139 0000AAAA           2042      AND.B       D0,$AAAA                ; Absolute Word Address
000072F6  C139 AAAAAAAA           2043      AND.B       D0,$AAAAAAAA            ; Absolute Long Address
000072FC                          2044  
000072FC                          2045      *WORD*
000072FC  C151                    2046      AND.W       D0,(A1)                 ; Addr Reg Indirect
000072FE  C159                    2047      AND.W       D0,(A1)+                ; Addr Reg Indirect with Post increment
00007300  C161                    2048      AND.W       D0,-(A1)                ; Addr Reg Indirect with Pre decrement
00007302  C179 0000AAAA           2049      AND.W       D0,$AAAA                ; Absolute Word Address
00007308  C179 AAAAAAAA           2050      AND.W       D0,$AAAAAAAA            ; Absolute Long Address
0000730E                          2051  
0000730E                          2052      *LONG*
0000730E  C191                    2053      AND.L       D0,(A1)                 ; Addr Reg Indirect
00007310  C199                    2054      AND.L       D0,(A1)+                ; Addr Reg Indirect with Post increment
00007312  C1A1                    2055      AND.L       D0,-(A1)                ; Addr Reg Indirect with Pre decrement
00007314  C1B9 0000AAAA           2056      AND.L       D0,$AAAA                ; Absolute Word Address
0000731A  C1B9 AAAAAAAA           2057      AND.L       D0,$AAAAAAAA            ; Absolute Long Address
00007320                          2058  
00007320                          2059  *******************************************************************************
00007320                          2060  *   ANDI        #<data>,<ea>            ; Size = (Byte, Word, Long)
00007320                          2061  *******************************************************************************
00007320                          2062  
00007320                          2063      *BYTE*                              **DESTINATION <ea>**
00007320  0201 00DD               2064      ANDI.B      #$DD,D1                 ; Data Register Direct
00007324  0211 00DD               2065      ANDI.B      #$DD,(A1)               ; Addr Reg Indirect
00007328  0219 00DD               2066      ANDI.B      #$DD,(A1)+              ; Addr Reg Indirect with Post increment
0000732C  0221 00DD               2067      ANDI.B      #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
00007330  0239 00DD 0000AAAA      2068      ANDI.B      #$DD,$AAAA              ; Absolute Word Address
00007338  0239 00DD AAAAAAAA      2069      ANDI.B      #$DD,$AAAAAAAA          ; Absolute Long Address
00007340                          2070  
00007340                          2071      *WORD*
00007340  0241 DDDD               2072      ANDI.W      #$DDDD,D1               ; Data Register Direct
00007344  0251 DDDD               2073      ANDI.W      #$DDDD,(A1)             ; Addr Reg Indirect
00007348  0259 DDDD               2074      ANDI.W      #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
0000734C  0261 DDDD               2075      ANDI.W      #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
00007350  0279 DDDD 0000AAAA      2076      ANDI.W      #$DDDD,$AAAA            ; Absolute Word Address
00007358  0279 DDDD AAAAAAAA      2077      ANDI.W      #$DDDD,$AAAAAAAA        ; Absolute Long Address
00007360                          2078  
00007360                          2079      *LONG*
00007360  0281 DDDDDDDD           2080      ANDI.L      #$DDDDDDDD,D1           ; Data Register Direct
00007366  0291 DDDDDDDD           2081      ANDI.L      #$DDDDDDDD,(A1)         ; Addr Reg Indirect
0000736C  0299 DDDDDDDD           2082      ANDI.L      #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
00007372  02A1 DDDDDDDD           2083      ANDI.L      #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
00007378  02B9 DDDDDDDD 0000AAAA  2084      ANDI.L      #$DDDDDDDD,$AAAA        ; Absolute Word Address
00007382  02B9 DDDDDDDD AAAAAAAA  2085      ANDI.L      #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
0000738C                          2086  
0000738C                          2087  *******************************************************************************
0000738C                          2088  *   OR          <ea>,Dn                 ; Size = (Byte, Word, Long)
0000738C                          2089  *******************************************************************************
0000738C                          2090  
0000738C                          2091      *BYTE*                              **SOURCE <ea>**
0000738C  8200                    2092      OR.B        D0,D1                   ; Data Register Direct
0000738E  8210                    2093      OR.B        (A0),D1                 ; Addr Reg Indirect
00007390  8218                    2094      OR.B        (A0)+,D1                ; Addr Reg Indirect with Post increment
00007392  8220                    2095      OR.B        -(A0),D1                ; Addr Reg Indirect with Pre decrement
00007394  8239 0000AAAA           2096      OR.B        $AAAA,D1                ; Absolute Word Address
0000739A  8239 AAAAAAAA           2097      OR.B        $AAAAAAAA,D1            ; Absolute Long Address
000073A0  823C 00DD               2098      OR.B        #$DD,D1                 ; Immediate Data
000073A4                          2099  
000073A4                          2100      *WORD*
000073A4  8240                    2101      OR.W        D0,D1                   ; Data Register Direct
000073A6  8250                    2102      OR.W        (A0),D1                 ; Addr Reg Indirect
000073A8  8258                    2103      OR.W        (A0)+,D1                ; Addr Reg Indirect with Post increment
000073AA  8260                    2104      OR.W        -(A0),D1                ; Addr Reg Indirect with Pre decrement
000073AC  8279 0000AAAA           2105      OR.W        $AAAA,D1                ; Absolute Word Address
000073B2  8279 AAAAAAAA           2106      OR.W        $AAAAAAAA,D1            ; Absolute Long Address
000073B8  827C 00DD               2107      OR.W        #$DD,D1                 ; Immediate Data
000073BC                          2108  
000073BC                          2109      *LONG*
000073BC  8280                    2110      OR.L        D0,D1                   ; Data Register Direct
000073BE  8290                    2111      OR.L        (A0),D1                 ; Addr Reg Indirect
000073C0  8298                    2112      OR.L        (A0)+,D1                ; Addr Reg Indirect with Post increment
000073C2  82A0                    2113      OR.L        -(A0),D1                ; Addr Reg Indirect with Pre decrement
000073C4  82B9 0000AAAA           2114      OR.L        $AAAA,D1                ; Absolute Word Address
000073CA  82B9 AAAAAAAA           2115      OR.L        $AAAAAAAA,D1            ; Absolute Long Address
000073D0  82BC 000000DD           2116      OR.L        #$DD,D1                 ; Immediate Data
000073D6                          2117  
000073D6                          2118  
000073D6                          2119  *******************************************************************************
000073D6                          2120  *   OR           Dn,<ea>                ; Size = (Byte, Word, Long)
000073D6                          2121  *******************************************************************************
000073D6                          2122  
000073D6                          2123      *BYTE*                              **DESTINATION <ea>**
000073D6  8111                    2124      OR.B         D0,(A1)                ; Addr Reg Indirect
000073D8  8119                    2125      OR.B         D0,(A1)+               ; Addr Reg Indirect with Post increment
000073DA  8121                    2126      OR.B         D0,-(A1)               ; Addr Reg Indirect with Pre decrement
000073DC  8139 0000AAAA           2127      OR.B         D0,$AAAA               ; Absolute Word Address
000073E2  8139 AAAAAAAA           2128      OR.B         D0,$AAAAAAAA           ; Absolute Long Address
000073E8                          2129  
000073E8                          2130      *WORD*
000073E8  8151                    2131      OR.W         D0,(A1)                ; Addr Reg Indirect
000073EA  8159                    2132      OR.W         D0,(A1)+               ; Addr Reg Indirect with Post increment
000073EC  8161                    2133      OR.W         D0,-(A1)               ; Addr Reg Indirect with Pre decrement
000073EE  8179 0000AAAA           2134      OR.W         D0,$AAAA               ; Absolute Word Address
000073F4  8179 AAAAAAAA           2135      OR.W         D0,$AAAAAAAA           ; Absolute Long Address
000073FA                          2136  
000073FA                          2137      *LONG*
000073FA  8191                    2138      OR.L         D0,(A1)                ; Addr Reg Indirect
000073FC  8199                    2139      OR.L         D0,(A1)+               ; Addr Reg Indirect with Post increment
000073FE  81A1                    2140      OR.L         D0,-(A1)               ; Addr Reg Indirect with Pre decrement
00007400  81B9 0000AAAA           2141      OR.L         D0,$AAAA               ; Absolute Word Address
00007406  81B9 AAAAAAAA           2142      OR.L         D0,$AAAAAAAA           ; Absolute Long Address
0000740C                          2143  
0000740C                          2144  
0000740C                          2145  *******************************************************************************
0000740C                          2146  *   ORI         #<data>,<ea>            ; Size = (Byte, Word, Long)
0000740C                          2147  *******************************************************************************
0000740C                          2148  
0000740C                          2149      *BYTE*                              **DESTINATION <ea>**
0000740C  0001 00DD               2150      ORI.B       #$DD,D1                 ; Data Register Direct
00007410  0011 00DD               2151      ORI.B       #$DD,(A1)               ; Addr Reg Indirect
00007414  0019 00DD               2152      ORI.B       #$DD,(A1)+              ; Addr Reg Indirect with Post increment
00007418  0021 00DD               2153      ORI.B       #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
0000741C  0039 00DD 0000AAAA      2154      ORI.B       #$DD,$AAAA              ; Absolute Word Address
00007424  0039 00DD AAAAAAAA      2155      ORI.B       #$DD,$AAAAAAAA          ; Absolute Long Address
0000742C                          2156  
0000742C                          2157      *WORD*
0000742C  0041 DDDD               2158      ORI.W       #$DDDD,D1               ; Data Register Direct
00007430  0051 DDDD               2159      ORI.W       #$DDDD,(A1)             ; Addr Reg Indirect
00007434  0059 DDDD               2160      ORI.W       #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
00007438  0061 DDDD               2161      ORI.W       #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
0000743C  0079 DDDD 0000AAAA      2162      ORI.W       #$DDDD,$AAAA            ; Absolute Word Address
00007444  0079 DDDD AAAAAAAA      2163      ORI.W       #$DDDD,$AAAAAAAA        ; Absolute Long Address
0000744C                          2164  
0000744C                          2165      *LONG*
0000744C  0081 DDDDDDDD           2166      ORI.L       #$DDDDDDDD,D1           ; Data Register Direct
00007452  0091 DDDDDDDD           2167      ORI.L       #$DDDDDDDD,(A1)         ; Addr Reg Indirect
00007458  0099 DDDDDDDD           2168      ORI.L       #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
0000745E  00A1 DDDDDDDD           2169      ORI.L       #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
00007464  00B9 DDDDDDDD 0000AAAA  2170      ORI.L       #$DDDDDDDD,$AAAA        ; Absolute Word Address
0000746E  00B9 DDDDDDDD AAAAAAAA  2171      ORI.L       #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
00007478                          2172  
00007478                          2173  *******************************************************************************
00007478                          2174  *   EOR        Dn,<ea>                  ; Size = (Byte, Word, Long)
00007478                          2175  *******************************************************************************
00007478                          2176  
00007478                          2177      *BYTE*                              **DESTINATION <ea>**
00007478  B101                    2178      EOR.B      D0,D1                    ; Data Register Direct
0000747A  B111                    2179      EOR.B      D0,(A1)                  ; Addr Reg Indirect
0000747C  B119                    2180      EOR.B      D0,(A1)+                 ; Addr Reg Indirect with Post increment
0000747E  B121                    2181      EOR.B      D0,-(A1)                 ; Addr Reg Indirect with Pre decrement
00007480  B139 0000AAAA           2182      EOR.B      D0,$AAAA                 ; Absolute Word Address
00007486  B139 AAAAAAAA           2183      EOR.B      D0,$AAAAAAAA             ; Absolute Long Address
0000748C                          2184  
0000748C                          2185      *WORD*
0000748C  B141                    2186      EOR.W      D0,D1                    ; Data Register Direct
0000748E  B151                    2187      EOR.W      D0,(A1)                  ; Addr Reg Indirect
00007490  B159                    2188      EOR.W      D0,(A1)+                 ; Addr Reg Indirect with Post increment
00007492  B161                    2189      EOR.W      D0,-(A1)                 ; Addr Reg Indirect with Pre decrement
00007494  B179 0000AAAA           2190      EOR.W      D0,$AAAA                 ; Absolute Word Address
0000749A  B179 AAAAAAAA           2191      EOR.W      D0,$AAAAAAAA             ; Absolute Long Address
000074A0                          2192  
000074A0                          2193      *LONG*
000074A0  B181                    2194      EOR.L      D0,D1                    ; Data Register Direct
000074A2  B191                    2195      EOR.L      D0,(A1)                  ; Addr Reg Indirect
000074A4  B199                    2196      EOR.L      D0,(A1)+                 ; Addr Reg Indirect with Post increment
000074A6  B1A1                    2197      EOR.L      D0,-(A1)                 ; Addr Reg Indirect with Pre decrement
000074A8  B1B9 0000AAAA           2198      EOR.L      D0,$AAAA                 ; Absolute Word Address
000074AE  B1B9 AAAAAAAA           2199      EOR.L      D0,$AAAAAAAA             ; Absolute Long Address
000074B4                          2200  
000074B4                          2201  *******************************************************************************
000074B4                          2202  *   EORI        #<data>,<ea>            ; Size = (Byte, Word, Long)
000074B4                          2203  *******************************************************************************
000074B4                          2204  
000074B4                          2205      *BYTE*                              **DESTINATION <ea>**
000074B4  0A01 00DD               2206      EORI.B      #$DD,D1                 ; Data Register Direct
000074B8  0A11 00DD               2207      EORI.B      #$DD,(A1)               ; Addr Reg Indirect
000074BC  0A19 00DD               2208      EORI.B      #$DD,(A1)+              ; Addr Reg Indirect with Post increment
000074C0  0A21 00DD               2209      EORI.B      #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
000074C4  0A39 00DD 0000AAAA      2210      EORI.B      #$DD,$AAAA              ; Absolute Word Address
000074CC  0A39 00DD AAAAAAAA      2211      EORI.B      #$DD,$AAAAAAAA          ; Absolute Long Address
000074D4                          2212  
000074D4                          2213      *WORD*
000074D4  0A41 DDDD               2214      EORI.W      #$DDDD,D1               ; Data Register Direct
000074D8  0A51 DDDD               2215      EORI.W      #$DDDD,(A1)             ; Addr Reg Indirect
000074DC  0A59 DDDD               2216      EORI.W      #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
000074E0  0A61 DDDD               2217      EORI.W      #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
000074E4  0A79 DDDD 0000AAAA      2218      EORI.W      #$DDDD,$AAAA            ; Absolute Word Address
000074EC  0A79 DDDD AAAAAAAA      2219      EORI.W      #$DDDD,$AAAAAAAA        ; Absolute Long Address
000074F4                          2220  
000074F4                          2221      *LONG*
000074F4  0A81 DDDDDDDD           2222      EORI.L      #$DDDDDDDD,D1           ; Data Register Direct
000074FA  0A91 DDDDDDDD           2223      EORI.L      #$DDDDDDDD,(A1)         ; Addr Reg Indirect
00007500  0A99 DDDDDDDD           2224      EORI.L      #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
00007506  0AA1 DDDDDDDD           2225      EORI.L      #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
0000750C  0AB9 DDDDDDDD 0000AAAA  2226      EORI.L      #$DDDDDDDD,$AAAA        ; Absolute Word Address
00007516  0AB9 DDDDDDDD AAAAAAAA  2227      EORI.L      #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
00007520                          2228  
00007520                          2229  *******************************************************************************
00007520                          2230  *   ASd where d is direction, L or R
00007520                          2231  *******************************************************************************
00007520                          2232  
00007520                          2233  *******************************************************************************
00007520                          2234  *   ASL         Dx,Dy                   ; Size = (Byte, Word, Long)
00007520                          2235  *   ASL         #<data>,Dy
00007520                          2236  *   ASL         <ea>
00007520                          2237  *******************************************************************************
00007520                          2238  
00007520                          2239      *BYTE*                              **DESTINATION <ea>**
00007520  E121                    2240      ASL.B       D0,D1
00007522                          2241  
00007522                          2242      *WORD*
00007522  E161                    2243      ASL.W       D0,D1
00007524  E341                    2244      ASL.W       #1,D1
00007526  E1D1                    2245      ASL.W       (A1)                    ; Addr Reg Indirect
00007528  E1D9                    2246      ASL.W       (A1)+                   ; Addr Reg Indirect with Post increment
0000752A  E1E1                    2247      ASL.W       -(A1)                   ; Addr Reg Indirect with Pre decrement
0000752C  E1F9 0000AAAA           2248      ASL.W       $AAAA                   ; Absolute Word Address
00007532  E1F9 AAAAAAAA           2249      ASL.W       $AAAAAAAA               ; Absolute Long Address
00007538                          2250  
00007538                          2251      *LONG*
00007538  E1A1                    2252      ASL.L       D0,D1
0000753A                          2253  
0000753A                          2254  *******************************************************************************
0000753A                          2255  *   ASR         Dx,Dy                   ; Size = (Byte, Word, Long)
0000753A                          2256  *   ASR         #<data>,Dy
0000753A                          2257  *   ASR         <ea>
0000753A                          2258  *******************************************************************************
0000753A                          2259  
0000753A                          2260      *BYTE*                              **DESTINATION <ea>**
0000753A  E021                    2261      ASR.B       D0,D1
0000753C                          2262  
0000753C                          2263      *WORD*
0000753C  E061                    2264      ASR.W       D0,D1
0000753E  E241                    2265      ASR.W       #1,D1
00007540  E0D1                    2266      ASR.W       (A1)                    ; Addr Reg Indirect
00007542  E0D9                    2267      ASR.W       (A1)+                   ; Addr Reg Indirect with Post increment
00007544  E0E1                    2268      ASR.W       -(A1)                   ; Addr Reg Indirect with Pre decrement
00007546  E0F9 0000AAAA           2269      ASR.W       $AAAA                   ; Absolute Word Address
0000754C  E0F9 AAAAAAAA           2270      ASR.W       $AAAAAAAA               ; Absolute Long Address
00007552                          2271  
00007552                          2272      *LONG*
00007552  E0A1                    2273      ASR.L       D0,D1
00007554                          2274  
00007554                          2275  *******************************************************************************
00007554                          2276  *   ROd where d is direction, L or R
00007554                          2277  *******************************************************************************
00007554                          2278  
00007554                          2279  *******************************************************************************
00007554                          2280  *   ROL         Dx,Dy                   ; Size = (Byte, Word, Long)
00007554                          2281  *   ROL         #<data>,Dy
00007554                          2282  *   ROL         <ea>
00007554                          2283  *******************************************************************************
00007554                          2284  
00007554                          2285      *BYTE*                              **DESTINATION <ea>**
00007554  E139                    2286      ROL.B       D0,D1
00007556                          2287  
00007556                          2288      *WORD*
00007556  E179                    2289      ROL.W       D0,D1
00007558  E359                    2290      ROL.W       #1,D1
0000755A  E7D1                    2291      ROL.W       (A1)                    ; Addr Reg Indirect
0000755C  E7D9                    2292      ROL.W       (A1)+                   ; Addr Reg Indirect with Post increment
0000755E  E7E1                    2293      ROL.W       -(A1)                   ; Addr Reg Indirect with Pre decrement
00007560  E7F9 0000AAAA           2294      ROL.W       $AAAA                   ; Absolute Word Address
00007566  E7F9 AAAAAAAA           2295      ROL.W       $AAAAAAAA               ; Absolute Long Address
0000756C                          2296  
0000756C                          2297      *LONG*
0000756C  E1B9                    2298      ROL.L       D0,D1
0000756E                          2299  
0000756E                          2300  *******************************************************************************
0000756E                          2301  *   ROR         Dx,Dy                   ; Size = (Byte, Word, Long)
0000756E                          2302  *   ROR         #<data>,Dy
0000756E                          2303  *   ROR         <ea>
0000756E                          2304  *******************************************************************************
0000756E                          2305  
0000756E                          2306      *BYTE*                              **DESTINATION <ea>**
0000756E  E039                    2307      ROR.B       D0,D1
00007570                          2308  
00007570                          2309      *WORD*
00007570  E079                    2310      ROR.W       D0,D1
00007572  E259                    2311      ROR.W       #1,D1
00007574  E6D1                    2312      ROR.W       (A1)                    ; Addr Reg Indirect
00007576  E6D9                    2313      ROR.W       (A1)+                   ; Addr Reg Indirect with Post increment
00007578  E6E1                    2314      ROR.W       -(A1)                   ; Addr Reg Indirect with Pre decrement
0000757A  E6F9 0000AAAA           2315      ROR.W       $AAAA                   ; Absolute Word Address
00007580  E6F9 AAAAAAAA           2316      ROR.W       $AAAAAAAA               ; Absolute Long Address
00007586                          2317  
00007586                          2318      *LONG*
00007586  E0B9                    2319      ROR.L       D0,D1
00007588                          2320  
00007588                          2321  *******************************************************************************
00007588                          2322  *   CMP         <ea>,Dn                 ; Size = (Byte, Word, Long)
00007588                          2323  *******************************************************************************
00007588                          2324  
00007588                          2325      *BYTE*                              **SOURCE <ea>**
00007588  B200                    2326      CMP.B       D0,D1                   ; Data Register Direct
0000758A  B210                    2327      CMP.B       (A0),D1                 ; Addr Reg Indirect
0000758C  B218                    2328      CMP.B       (A0)+,D1                ; Addr Reg Indirect with Post increment
0000758E  B220                    2329      CMP.B       -(A0),D1                ; Addr Reg Indirect with Pre decrement
00007590  B239 0000AAAA           2330      CMP.B       $AAAA,D1                ; Absolute Word Address
00007596  B239 AAAAAAAA           2331      CMP.B       $AAAAAAAA,D1            ; Absolute Long Address
0000759C  B23C 00DD               2332      CMP.B       #$DD,D1                 ; Immediate Data
000075A0                          2333  
000075A0                          2334      *WORD*
000075A0  B240                    2335      CMP.W       D0,D1                   ; Data Register Direct
000075A2  B248                    2336      CMP.W       A0,D1                   ; Addr Reg Direct
000075A4  B250                    2337      CMP.W       (A0),D1                 ; Addr Reg Indirect
000075A6  B258                    2338      CMP.W       (A0)+,D1                ; Addr Reg Indirect with Post increment
000075A8  B260                    2339      CMP.W       -(A0),D1                ; Addr Reg Indirect with Pre decrement
000075AA  B279 0000AAAA           2340      CMP.W       $AAAA,D1                ; Absolute Word Address
000075B0  B279 AAAAAAAA           2341      CMP.W       $AAAAAAAA,D1            ; Absolute Long Address
000075B6  B27C 00DD               2342      CMP.W       #$DD,D1                 ; Immediate Data
000075BA                          2343  
000075BA                          2344      *LONG*
000075BA  B280                    2345      CMP.L       D0,D1                   ; Data Register Direct
000075BC  B288                    2346      CMP.L       A0,D1                   ; Addr Reg Direct
000075BE  B290                    2347      CMP.L       (A0),D1                 ; Addr Reg Indirect
000075C0  B298                    2348      CMP.L       (A0)+,D1                ; Addr Reg Indirect with Post increment
000075C2  B2A0                    2349      CMP.L       -(A0),D1                ; Addr Reg Indirect with Pre decrement
000075C4  B2B9 0000AAAA           2350      CMP.L       $AAAA,D1                ; Absolute Word Address
000075CA  B2B9 AAAAAAAA           2351      CMP.L       $AAAAAAAA,D1            ; Absolute Long Address
000075D0  B2BC 000000DD           2352      CMP.L       #$DD,D1                 ; Immediate Data
000075D6                          2353  
000075D6                          2354  *******************************************************************************
000075D6                          2355  *   CMPA        <ea>,An                 ; Size = (Word, Long)
000075D6                          2356  *******************************************************************************
000075D6                          2357  
000075D6                          2358  
000075D6                          2359      *WORD*                              **SOURCE <ea>**
000075D6  B2C0                    2360      CMPA.W       D0,A1                  ; Data Register Direct
000075D8  B2C8                    2361      CMPA.W       A0,A1                  ; Addr Reg Direct
000075DA  B2D0                    2362      CMPA.W       (A0),A1                ; Addr Reg Indirect
000075DC  B2D8                    2363      CMPA.W       (A0)+,A1               ; Addr Reg Indirect with Post increment
000075DE  B2E0                    2364      CMPA.W       -(A0),A1               ; Addr Reg Indirect with Pre decrement
000075E0  B2F9 0000AAAA           2365      CMPA.W       $AAAA,A1               ; Absolute Word Address
000075E6  B2F9 AAAAAAAA           2366      CMPA.W       $AAAAAAAA,A1           ; Absolute Long Address
000075EC  B2FC 00DD               2367      CMPA.W       #$DD,A1                ; Immediate Data
000075F0                          2368  
000075F0                          2369      *LONG*
000075F0  B3C0                    2370      CMPA.L       D0,A1                  ; Data Register Direct
000075F2  B3C8                    2371      CMPA.L       A0,A1                  ; Addr Reg Direct
000075F4  B3D0                    2372      CMPA.L       (A0),A1                ; Addr Reg Indirect
000075F6  B3D8                    2373      CMPA.L       (A0)+,A1               ; Addr Reg Indirect with Post increment
000075F8  B3E0                    2374      CMPA.L       -(A0),A1               ; Addr Reg Indirect with Pre decrement
000075FA  B3F9 0000AAAA           2375      CMPA.L       $AAAA,A1               ; Absolute Word Address
00007600  B3F9 AAAAAAAA           2376      CMPA.L       $AAAAAAAA,A1           ; Absolute Long Address
00007606  B3FC 000000DD           2377      CMPA.L       #$DD,A1                ; Immediate Data
0000760C                          2378  
0000760C                          2379  *******************************************************************************
0000760C                          2380  *   CMPI        #<data>,<ea>            ; Size = (Byte, Word, Long)
0000760C                          2381  *******************************************************************************
0000760C                          2382  
0000760C                          2383      *BYTE*                              **DESTINATION <ea>**
0000760C  0C01 00DD               2384      CMPI.B      #$DD,D1                 ; Data Register Direct
00007610  0C11 00DD               2385      CMPI.B      #$DD,(A1)               ; Addr Reg Indirect
00007614  0C19 00DD               2386      CMPI.B      #$DD,(A1)+              ; Addr Reg Indirect with Post increment
00007618  0C21 00DD               2387      CMPI.B      #$DD,-(A1)              ; Addr Reg Indirect with Pre decrement
0000761C  0C39 00DD 0000AAAA      2388      CMPI.B      #$DD,$AAAA              ; Absolute Word Address
00007624  0C39 00DD AAAAAAAA      2389      CMPI.B      #$DD,$AAAAAAAA          ; Absolute Long Address
0000762C                          2390  
0000762C                          2391      *WORD*
0000762C  0C41 DDDD               2392      CMPI.W      #$DDDD,D1               ; Data Register Direct
00007630  0C51 DDDD               2393      CMPI.W      #$DDDD,(A1)             ; Addr Reg Indirect
00007634  0C59 DDDD               2394      CMPI.W      #$DDDD,(A1)+            ; Addr Reg Indirect with Post increment
00007638  0C61 DDDD               2395      CMPI.W      #$DDDD,-(A1)            ; Addr Reg Indirect with Pre decrement
0000763C  0C79 DDDD 0000AAAA      2396      CMPI.W      #$DDDD,$AAAA            ; Absolute Word Address
00007644  0C79 DDDD AAAAAAAA      2397      CMPI.W      #$DDDD,$AAAAAAAA        ; Absolute Long Address
0000764C                          2398  
0000764C                          2399      *LONG*
0000764C  0C81 DDDDDDDD           2400      CMPI.L      #$DDDDDDDD,D1           ; Data Register Direct
00007652  0C91 DDDDDDDD           2401      CMPI.L      #$DDDDDDDD,(A1)         ; Addr Reg Indirect
00007658  0C99 DDDDDDDD           2402      CMPI.L      #$DDDDDDDD,(A1)+        ; Addr Reg Indirect with Post increment
0000765E  0CA1 DDDDDDDD           2403      CMPI.L      #$DDDDDDDD,-(A1)        ; Addr Reg Indirect with Pre decrement
00007664  0CB9 DDDDDDDD 0000AAAA  2404      CMPI.L      #$DDDDDDDD,$AAAA        ; Absolute Word Address
0000766E  0CB9 DDDDDDDD AAAAAAAA  2405      CMPI.L      #$DDDDDDDD,$AAAAAAAA    ; Absolute Long Address
00007678                          2406  
00007678                          2407  *******************************************************************************
00007678                          2408  *   Bcc         <label>                 ; Size = (Byte, Word, Long*)
00007678                          2409  *******************************************************************************
00007678                          2410  
00007678  6400 0012               2411      BCC         carry_clear
0000767C  6500 000E               2412      BCS         carry_set
00007680  6700 000A               2413      BEQ         equal
00007684  6800 0006               2414      BVC         overflow_clear
00007688  6900 0002               2415      BVS         overflow_set
0000768C                          2416  
0000768C                          2417  *******************************************************************************
0000768C                          2418  *                       End Test Disassemble Routines
0000768C                          2419  *******************************************************************************
0000768C                          2420  carry_clear
0000768C                          2421  carry_set
0000768C                          2422  equal
0000768C                          2423  greater_or_equal
0000768C                          2424  greater_than
0000768C                          2425  high
0000768C                          2426  less_or_equal
0000768C                          2427  low_or_same
0000768C                          2428  less_than
0000768C                          2429  minus
0000768C                          2430  not_equal
0000768C                          2431  plus
0000768C                          2432  overflow_clear
0000768C                          2433  overflow_set
0000768C                          2434  
0000768C                          2435              END         start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   41
ADDA_               1AB0
ADDI_               1842
ADDQ_               196E
ADDRLEN             8
ADDR_LOOP           1168
ADDR_REGS           1438
ADD_LONG_BUF        1F4A
ADD_WORD_BUF        1F54
ANDI_               181A
AND_                1A9A
ASCII_IMMEDIATE     147C
ASCII_LOOP          127C
ASCII_OPCODE_ADDRESS  1734
ASCII_W             1468
ASC_WRD             21A2
ASD_MS              1B82
ASD_ROD             1AD2
ASD_ROD_MS          1B68
ASD_ROD_RS          1AE4
ASD_ROD_SIZE        1BB6
ASD_RS              1AFE
A_LETCONV           12A4
A_NUMCONV           129C
A_RETURN            12B6
A_SAVE              12AC
A_SHIFT             12B0
BADFLAG             1262
BADSTART            FFFFE
BCC_                19B6
BCS_                19C0
BEQ_                19CA
BLW                 1CB8
BVC_                19D4
BVS_                19DE
BWL                 1C8C
BYTE_               1CD2
BYTE_BUF_DONE       130E
B_                  1984
CARRY_CLEAR         768C
CARRY_SET           768C
CARR_RET            1434
CARR_RETLEN         1435
CHECK_EVEN          1310
CLOSE_PAREN         216A
CLOSE_PARENLEN      216C
CLRBUF              11D6
CLRLOOP             11E2
CLR_REGS            11F2
CMPA_               1A32
CMPI_               186E
CMP_                1A66
COL_TEMPLATE        13D8
COMMA               2C
COMMA_SIGN          217A
COMMA_SIGNLEN       217C
COMPLEX             1B1E
CONTI               16EC
CONTIL              1732
CONTROL             113C
CONT_ROD_IND        1B3A
CONT_ROD_REG        1B2A
CONV_TO_ASCII       1270
CONV_TO_HEX         1204
CR                  D
C_TEMP_LEN          13EC
D                   44
D0TOD5              1C84
D12TOD15            1C3E
D3TOD4              1C7A
D6TOD11             1C66
D6TOD7              1C70
D8                  1C5C
D8TOD11             1C48
D9TOD11             1C52
DATA                1BC2
DATA1               1380
DATA2               1394
DATAST              13C4
DATA_REGS           1450
DECISION            13A8
DIRECTION           1BAA
DOLLAR              24
DOLLAR_SIGN         2176
DOLLAR_SIGNLEN      2178
DONE                12F6
EAINDEX000          1E92
EAINDEX001          1E9E
EAINDEX010          1EAA
EAINDEX011          1EC0
EAINDEX100          1EDA
EAINDEX101          1EF4
EAINDEX110          1F60
EAINDEX111          1F72
EAR_DECODE          1E40
EAR_MOVEM           20C0
EASUB000            1FB8
EASUB001            1FE0
EASUB010            2022
EASUB011            20B8
EASUB100            205E
EASUB100_BADLEN     20B2
EASUB100_L          2076
EASUB101            20BA
EASUB110            20BC
EASUB111            20BE
EA_INDEX_TABLE      1E62
ENDADD              155C
ENDADDL             15D0
ENDADDR             FFFFF
ENDERR              1362
ENDERROR            162A
ENDERRORL           169C
END_HEX             13C0
END_LOGIC           1DA8
END_OCR             17C2
EORI_               1858
EOR_                1A84
EOR_CMP             1A54
EOR_CMP_CMPA        1A20
EQUAL               768C
EVEN                132C
EVENAND             1
EXITBUF             11F0
EXITBUFPRT          11D0
EXIT_IO             119C
F_SLASH             2192
F_SLASHLEN          2194
GREATER_OR_EQUAL    768C
GREATER_THAN        768C
GREET               1490
GREETERR            1332
GREETING            1014
GREETL              14EE
HEX_LOOP            1208
HIGH                768C
H_LETCONV           1252
H_NUMCONV           124A
H_RETURN            126A
H_UNCONV            125A
IERROR              169E
IERRORL             16EA
IMMEDIATE_ADDR      1D22
INVALIDB            1402
INVALIDB_END        1416
INVALIDB_LEN        14
ISDATAREG           130C
ISO_BITS            1BCA
ISO_D0_TO_D5_FOR_EA  1C0C
ISO_D6_TO_D11_FOR_EA  1C2E
JMP_                195E
JSR_                194E
LEFT                1CF6
LESS_OR_EQUAL       768C
LESS_THAN           768C
LF                  A
LINEFEED            1436
LINEFEEDLEN         1437
LOGIC_DESTINATION   1D78
LOGIC_OP_EA         1D42
LOGIC_SOURCE        1D5E
LOGIC_TABLE         1D56
LONG                208C
LONG_               1CDE
LONG_EXT            2184
LONG_EXTLEN         2188
LOW_OR_SAME         768C
LR                  1CE4
LWN                 6E
LWY                 79
MINUS               768C
MINUS_SIGN          2172
MINUS_SIGNLEN       2174
MOVEA_              1896
MOVEM_EXIT          2160
MOVE_               18B4
MOVE_MOVEA          1884
NEG_                18EC
NEG_NOP_RTS_JSR_JMP  18D2
NEW_LINE            1E3C
NEXT                20A2
NOP_                193E
NOP_RTS             1924
NOP_RTS_JSR_JMP     1902
NOT_EQUAL           768C
OCR                 173E
OPEN_PAREN          2166
OPEN_PARENLEN       2168
ORI_                1806
ORI_ANDI_SUBI_ADDI_EORI_CMPI  17CC
OR_                 19E8
OUTCT               19
OVERFLOW_CLEAR      768C
OVERFLOW_SET        768C
PAGEFULL            118A
PAGE_BUFFER         119E
PLUS                768C
PLUS_SIGN           216E
PLUS_SIGNLEN        2170
POST_CLR            2120
POST_DATA           2100
POST_INCR           210A
POST_LOOP           20E8
POST_SKIP           2104
POUND_SIGN          2196
POUND_SIGNLEN       2198
PREDEC_CLR          215C
PREDEC_DATA         213C
PREDEC_INCR         2146
PREDEC_LOOP         2124
PREDEC_SKIP         2140
PROCEND             10CA
PROCSTART           1058
PROG_CTR            218A
PROG_CTRLEN         2190
PRTBUF              11B2
PRTLOOP             11BE
REGION              50
RIGHT               1CF0
ROD_MS              1B96
ROD_RS              1B12
ROD_WORD            1B5A
RTS_                1946
SEND_ADDR_BUF       12C0
SEND_BYTE_BUF       12FC
SEND_DATA_BUF       12DE
SKIP                2008
SPACE               20
SPACING             1DAE
STACK               100000
STADD               14F0
STADDL              155A
START               1000
STARTERR            1348
START_HEX           13BC
STERROR             15D2
STERRORL            1628
STP                 137C
STRTADDR            2000
SUBA_               19FE
SUBINDEX_TBL        1F88
SUBI_               182E
SWAP_REG_MODE       1CFC
T                   54
TAB_LEN             21A0
TAB_SIGN            219A
TASK0               0
TASK1               1
TASK2               2
TEMP                1416
UPN                 4E
UPY                 59
VALIDB              13EE
VALIDB_END          1402
VALIDB_LEN          14
WL                  1CA6
WORD                2096
WORDLEN             4
WORD_               1CD8
WORD_EXT            217E
WORD_EXTLEN         2182
_A0                 1438
_A1                 143B
_A2                 143E
_A3                 1441
_A4                 1444
_A5                 1447
_A6                 144A
_A7                 144D
_ADDA               1E28
_ADDI               1DC8
_ADDQ               1DF6
_AND                1E24
_ANDI               1DBE
_ASD                1E2D
_BCC                1DFB
_BCS                1DFF
_BEQ                1E03
_BVC                1E07
_BVS                1E0B
_BYTE               1DB1
_CMP                1E1B
_CMPA               1E1F
_CMPI               1DD2
_D0                 1450
_D1                 1453
_D2                 1456
_D3                 1459
_D4                 145C
_D5                 145F
_D6                 1462
_D7                 1465
_DATA               1E37
_EOR                1E17
_EORI               1DCD
_JMP                1DF2
_JSR                1DEE
_LEFT               1E33
_LONG               1DB7
_MOVE               1DD7
_MOVEA              1DDC
_NEG                1DE2
_NOP                1DE6
_OR                 1E0F
_ORI                1DBA
_RIGHT              1E35
_ROD                1E30
_RTS                1DEA
_SUBA               1E12
_SUBI               1DC3
_WORD               1DB4
